{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"method_",
				"method_with_block\tabc"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include <unistd.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <string.h>\n#include <netdb.h>\n#include <netinet/in.h>\n\n#include <sys/types.h>\n#include <sys/socket.h>\n\n#include <time.h>\n#include \"bandwidthd.h\"\n\n#ifdef HAVE_ARPA_NAMESER_H\n#include <arpa/nameser.h>\n#endif\n#ifdef HAVE_RESOLV_H\n#include <resolv.h>\n#endif\n\nextern unsigned int SubnetCount;\nextern struct config config;\n\njmp_buf dnsjump;\n\nstatic void rdnslngjmp(int signal);\n\nvoid rdns(char *Buffer, unsigned long IP)  // This takes over sigalarm!\n\t{\n#ifdef HAVE_RESOLV_H\n\tchar DNSError[] = \"DNS Timeout: Correct to speed up graphing\";\n\tchar None[] = \"Configure DNS to reverse this IP\";\n\tchar TooManyDNSTimeouts[] = \"Too many dns timeouts, reverse lookups suspended\";\n\tstruct hostent *hostent;\n\tchar chrIP[50];\n\tstatic int Init = TRUE;\n\tstatic int DNSTimeouts = 0;  // This is reset for each run because we're forked\n\tunsigned long addr = htonl(IP);\n\n    _res.retrans = 1;\n    _res.retry = 2;\n\n\tif (Init)\n\t\t{\n        signal(SIGALRM, rdnslngjmp);\n\t\tInit = FALSE;\n\t\t}\n\n\tif (DNSTimeouts > 100)\n\t\t{\n\t\tsyslog(LOG_ERR, \"Too many dns timeouts, reverse lookups suspended\");\n        strncpy(Buffer, TooManyDNSTimeouts, 253);\n\t\tBuffer[254] = '\\0';\n\t\treturn;\n\t\t}\t\t\n\n\tif (setjmp(dnsjump) == 0)\n\t\t{\n\t\talarm(10);  // Don't let gethostbyaddr hold us up too long\n\t\thostent = gethostbyaddr((char *) &addr, 4, AF_INET); // (char *)&Data->IP\t\t\t\t\n\t\talarm(0);\n\t\t\n\t\tif (hostent)\n\t\t\tsprintf(Buffer, \"%s\", hostent->h_name);\n\t\telse\n\t\t\t{\n\t        strncpy(Buffer, None, 253);\n\t\t\tBuffer[254] = '\\0';\n\t\t\t}\n\t\t}\n\telse  // Our alarm timed out\n\t\t{\n\t\tHostIp2CharIp(IP, chrIP);\n\t\tsyslog(LOG_ERR, \"DNS timeout for %s: This problem reduces graphing performance\", chrIP);\n\t\tDNSTimeouts++;\n        strncpy(Buffer, DNSError, 253);\n\t\tBuffer[254] = '\\0';\n\t\t}\n#else\n\tBuffer[0] = '\\0';\n#endif\n\t}\n\nstatic void rdnslngjmp(int signal)\n\t{\n    longjmp(dnsjump, 1);\n\t}\n\nvoid swap(struct SummaryData **a, struct SummaryData **b) {\n\tstruct SummaryData *temp;\n    temp = *a; *a = *b; *b = temp;\n}\nvoid QuickSortSummaryData(struct SummaryData *SummaryData[], int left, int right) {\n    int i,j,center;\n    unsigned long long pivot;\n    if (left==right) return;\n    if (left+1==right) {\n        if (SummaryData[left]->Total < SummaryData[right]->Total)\n            swap(&SummaryData[left],&SummaryData[right]);\n        return;\n    }\n    /* use the median-of-three method for picking pivot */\n    center = (left+right)/2;\n    if (SummaryData[left]->Total < SummaryData[center]->Total)\n        swap(&SummaryData[left],&SummaryData[center]);\n    if (SummaryData[left]->Total < SummaryData[right]->Total)\n        swap(&SummaryData[left],&SummaryData[right]);\n    if (SummaryData[center]->Total < SummaryData[right]->Total)\n        swap(&SummaryData[center],&SummaryData[right]);\n    pivot = SummaryData[center]->Total;\n    swap(&SummaryData[center],&SummaryData[right-1]); /* hide the pivot */\n    i = left; j = right - 1;\n    do {\n        do { ++i; } while (SummaryData[i]->Total > pivot);\n        do { --j; } while (SummaryData[j]->Total < pivot);\n        swap(&SummaryData[i],&SummaryData[j]);\n    } while (j > i);\n    swap(&SummaryData[i],&SummaryData[j]); /* undo last swap */\n    swap(&SummaryData[i],&SummaryData[right-1]); /* restore pivot */\n    QuickSortSummaryData(SummaryData,left,i-1);\n    QuickSortSummaryData(SummaryData,i+1,right);\n}\n\n#define NumFactor 1024\nstatic void FormatNum(unsigned long long n, char *buf, int len) {\n    double f;\n    if (n<NumFactor) { snprintf(buf,len,\"<td align=\\\"right\\\"><tt>%i&nbsp;</tt></td>\",(int)n); return; }\n    f = n;\n    f /= NumFactor; if (f<NumFactor) { snprintf(buf,len,\"<td align=\\\"right\\\"><tt>%.1fK</tt></td>\",f); return; }\n    f /= NumFactor; if (f<NumFactor) { snprintf(buf,len,\"<td align=\\\"right\\\"><tt>%.1fM</tt></td>\",f); return; }\n    f /= NumFactor; if (f<NumFactor) { snprintf(buf,len,\"<td align=\\\"right\\\"><tt>%.1fG</tt></td>\",f); return; }\n    f /= NumFactor; snprintf(buf,len,\"<td align=\\\"right\\\"><tt>%.1fT</tt></td>\\n\",f);\n}\n\nvoid PrintTableLine(FILE *stream, struct SummaryData *Data, int Counter)\n\t{\n\tchar Buffer1[50];\n\tchar Buffer1b[50];\n\tchar Buffer2[50];\n\tchar Buffer3[50];\n\tchar Buffer4[50];\n\tchar Buffer4b[50];\n\tchar Buffer5[50];\n\tchar Buffer5b[50];\n\tchar Buffer6[50];\n\tchar Buffer7[50];\n\tchar Buffer8[50];\n//\tchar IPHostName[50];\n\n\t// First convert the info to nice, human readable stuff\n\trdns(Buffer1b, Data->IP);\n\tif (Data->IP == 0)\n\t\tstrcpy(Buffer1, \"Total\");\n\t\t// For 0, the totals row, the output of rdns will be overwritten.\n\t\tBuffer1b[0]='\\0';\n\t\tstrcpy(Buffer1b, \"\"); \n\telse\n\t\tHostIp2CharIp(Data->IP, Buffer1);\n        // strcat(Buffer1, \"-\");\n\t\t// strcat(Buffer1, IPHostName);\n\n    FormatNum(Data->Total,         Buffer2,  50);\n\tFormatNum(Data->TotalSent,     Buffer3,  50);\n\tFormatNum(Data->TotalReceived, Buffer4,  50);\n\tFormatNum(Data->FTP, \t\t   Buffer4b, 50);\n\tFormatNum(Data->HTTP,          Buffer5,  50);\n\tFormatNum(Data->P2P,           Buffer5b, 50);\n\tFormatNum(Data->TCP,           Buffer6,  50);\n\tFormatNum(Data->UDP,           Buffer7,  50);\n\tFormatNum(Data->ICMP,          Buffer8,  50);\n\n\tif (Counter%4 == 0 || (Counter-1)%4 == 0)\n\t\tfprintf(stream, \"<TR>\");\n\telse\n\t\tfprintf(stream, \"<TR bgcolor=lightblue>\");\n\n\tif (Data->Graph)\n\t\tfprintf(stream, \"<TD><a href=\\\"#%s-%c\\\">%s</a></TD>%s%s%s%s%s%s%s%s%s</TR>\\n\",\n\t\t\tBuffer1, // Ip\n\t\t\tconfig.tag,\n\t\t\tBuffer1b, // Ip\n\t\t\tBuffer2, // Total\n\t\t\tBuffer3, // TotalSent\n\t\t\tBuffer4, // TotalReceived\n\t\t\tBuffer4b, // FTP\n\t\t\tBuffer5, // HTTP\n\t\t\tBuffer5b, // P2P\n\t\t\tBuffer6, // TCP\n\t\t\tBuffer7, // UDP\n\t\t\tBuffer8); // ICMP\n\telse\n\t\tfprintf(stream, \"<TD>%s</TD>%s%s%s%s%s%s%s%s%s</TR>\\n\",\n\t\t\tBuffer1, // Ip\n\t\t\tBuffer2, // Total\n\t\t\tBuffer3, // TotalSent\n\t\t\tBuffer4, // TotalReceived\n\t\t\tBuffer4b, // FTP\n\t\t\tBuffer5, // HTTP\n\t\t\tBuffer5b, // P2P\t\t\n\t\t\tBuffer6, // TCP\n\t\t\tBuffer7, // UDP\n\t\t\tBuffer8); // ICMP\n\t}\n\nvoid MakeIndexPages(int NumIps, struct SummaryData *SummaryData[])\n\t{\n\tint SubnetCounter;\n\tint Counter, tCounter;\n\ttime_t WriteTime;\n\tchar filename[] = \"./htdocs/index2.html\";\n\tchar *PeriodDesc;\n\t\n\tFILE *file;\n\n\tchar Buffer1[50];\n\tchar Buffer2[50];\n\tchar HostName[255];\n\n\tWriteTime = time(NULL);\n\t\n\tQuickSortSummaryData(SummaryData, 0, NumIps-1);\n\n\t////////////////////////////////////////////////\n\t// Print main index page\n\t\n\tif (config.tag == '1')\n\t\t{\n\t\tif ((file = fopen(\"./htdocs/index.html\", \"wt\")) == NULL)\n\t\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to open ./htdocs/index.html\");\n\t\t\texit(1);\n\t\t\t}\n\t\t}\n\telse\n\t\t{\n\t\tfilename[14] = config.tag;\n\t\tif ((file = fopen(filename, \"wt\")) == NULL)\n\t\t\t{\n\t\t\tsyslog(LOG_ERR, \"Failed to open %s\", filename);\n\t\t\texit(1);\n\t\t\t}\n\t\t}\n\n\tswitch (config.tag)\n\t\t{\n\t\tcase '1': PeriodDesc = \"Daily\"; break;\n\t\tcase '2': PeriodDesc = \"Weekly\"; break;\n\t\tcase '3': PeriodDesc = \"Monthly\"; break;\n\t\tcase '4': PeriodDesc = \"Yearly\"; break;\n\t\tdefault: PeriodDesc = \"\"; break;\n\t\t}\n\t\n\tfprintf(file, \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n\");\n\tfprintf(file, \"<HTML>\\n<HEAD>\\n<TITLE>Bandwidthd</TITLE>\\n\");\n\n\tif (config.meta_refresh)\n\t\tfprintf(file, \"<META HTTP-EQUIV=\\\"REFRESH\\\" content=\\\"%u\\\">\\n\",\n\t\t\t\tconfig.meta_refresh);\n\tfprintf(file, \"<META HTTP-EQUIV=\\\"EXPIRES\\\" content=\\\"-1\\\">\\n\");\n\tfprintf(file, \"<META HTTP-EQUIV=\\\"PRAGMA\\\" content=\\\"no-cache\\\">\\n\");\n\tfprintf(file, \"</HEAD>\\n<BODY vlink=blue>\\n%s<br>\\n<center><img src=\\\"logo.gif\\\" ALT=\\\"Logo\\\"><BR>\\n\", ctime(&WriteTime));\n\tfprintf(file, \"Programmed by David Hinkle, Commissioned by <a href=\\\"http://www.derbytech.com\\\">DerbyTech</a> wireless networking.<BR>\");\n\tfprintf(file, \"<BR>\\n - <a href=\\\"index.html\\\">Daily</a> -- <a href=\\\"index2.html\\\">Weekly</a> -- \");\n\tfprintf(file, \"<a href=\\\"index3.html\\\">Monthly</a> -- <a href=\\\"index4.html\\\">Yearly</a> - <BR>\\n\");\n\n\tfprintf(file, \"<BR>\\nPick a Subnet:<BR>\\n\");\t\n\tif (config.tag == '1')\n\t\tfprintf(file, \"- <a href=\\\"index.html\\\">Top20</a> -\");\n\telse\n\t\tfprintf(file, \"- <a href=\\\"index%c.html\\\">Top20</a> -\", config.tag);\n\n\tfor (Counter = 0; Counter < SubnetCount; Counter++)            \n\t\t{\n\t\tHostIp2CharIp(SubnetTable[Counter].ip, Buffer1);\n\t\tfprintf(file, \"- <a href=\\\"Subnet-%c-%s.html\\\">%s</a> -\", config.tag, Buffer1, Buffer1);\n\t\t}\n\n\t/////  TOP 20\n\n\tfprintf(file, \"<H1>Top 20 IPs by Traffic - %s</H1></center>\", PeriodDesc);\n\tfprintf(file, \"<center>\\n<table width=\\\"100%%\\\" border=1 cellspacing=0>\\n\");\n\n    // PASS 1:  Write out the table\n\n\tfprintf(file, \"<TR bgcolor=lightblue><TD>Ip and Name<TD align=center>Total<TD align=center>Total Sent<TD align=center>Total Received<TD align=center>FTP<TD align=center>HTTP<TD align=center>P2P<TD align=center>TCP<TD align=center>UDP<TD align=center>ICMP\\n\");\n\tfor (Counter=0; Counter < 21 && Counter < NumIps; Counter++)\n\t\tPrintTableLine(file, SummaryData[Counter], Counter);\n\n\tfprintf(file, \"</table></center>\\n\");\n\n\t// PASS 2: The graphs\n\tfor (Counter=0; Counter < 21 && Counter < NumIps; Counter++)\n\t\tif (SummaryData[Counter]->Graph)\n\t\t\t{\n\t\t\tif (SummaryData[Counter]->IP == 0)\n\t\t\t\t{\n\t\t\t\tstrcpy(Buffer1, \"Total\");\t\n\t\t\t\tstrcpy(HostName, \"Total of all subnets\");\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\t\n\t\t\t\tHostIp2CharIp(SummaryData[Counter]->IP, Buffer1);\n\t\t\t\trdns(HostName, SummaryData[Counter]->IP);\n\t\t\t\t}\n\t\t\tfprintf(file, \"<a name=\\\"%s-%c\\\"></a><H1><a href=\\\"#top\\\">(Top)</a> %s - %s</H1><BR>\\nSend:<br>\\n<img src=%s-%c-S.png ALT=\\\"Sent traffic for %s\\\"><BR>\\n<img src=legend.gif ALT=\\\"Legend\\\"><br>\\nReceived:<br>\\n<img src=%s-%c-R.png ALT=\\\"Sent traffic for %s\\\"><BR>\\n<img src=legend.gif ALT=\\\"Legend\\\"><br>\\n<BR>\\n\", Buffer1, config.tag, Buffer1, HostName, Buffer1, config.tag, Buffer1, Buffer1, config.tag, Buffer1);\n\t\t\t}\n\n\tfprintf(file, \"</BODY></HTML>\\n\");\n\n\tfclose(file);\n\n\t////////////////////////////////////////////////\n\t// Print each subnet page\n\n\tfor (SubnetCounter = 0; SubnetCounter < SubnetCount; SubnetCounter++)\n\t\t{\n\t\tHostIp2CharIp(SubnetTable[SubnetCounter].ip, Buffer1);\n\t\tsprintf(Buffer2, \"./htdocs/Subnet-%c-%s.html\", config.tag, Buffer1);\n\t\tfile = fopen(Buffer2, \"wt\");\n\t\tfprintf(file, \"<!DOCTYPE HTML PUBLIC \\\"-//W3C//DTD HTML 4.01 Transitional//EN\\\">\\n\");\n\t\tfprintf(file, \"<HTML>\\n<HEAD><TITLE>Bandwidthd - Subnet %s</TITLE>\\n\", Buffer1);\n\n\t\tif (config.meta_refresh)\n\t\t\tfprintf(file, \"<META HTTP-EQUIV=\\\"REFRESH\\\" content=\\\"%u\\\">\\n\",\n\t\t\t\t\tconfig.meta_refresh);\n\t\tfprintf(file, \"<META HTTP-EQUIV=\\\"EXPIRES\\\" content=\\\"-1\\\">\\n\");\n\t\tfprintf(file, \"<META HTTP-EQUIV=\\\"PRAGMA\\\" content=\\\"no-cache\\\">\\n\");\n\t\tfprintf(file, \"</HEAD>\\n<BODY vlink=blue>\\n%s<br>\\n<CENTER><a name=\\\"Top\\\"></a>\", ctime(&WriteTime));\n\t\tfprintf(file, \"<img src=\\\"logo.gif\\\" ALT=\\\"Logo\\\"><BR>\");\n\t\tfprintf(file, \"Programmed by David Hinkle, Commissioned by <a href=\\\"http://www.derbytech.com\\\">DerbyTech</a> wireless networking.<BR>\\n\");\n\n\t\tfprintf(file, \"<BR>\\n - <a href=\\\"index.html\\\">Daily</a> -- <a href=\\\"index2.html\\\">Weekly</a> -- \");\n\t\tfprintf(file, \"<a href=\\\"index3.html\\\">Monthly</a> -- <a href=\\\"index4.html\\\">Yearly</a> - <BR>\\n\");\n\n\t\tfprintf(file, \"<BR>\\nPick a Subnet:<BR>\\n\");\n\t\tif (config.tag == '1')\n\t\t\tfprintf(file, \"- <a href=\\\"index.html\\\">Top20</a> -\");\n\t\telse\n\t\t\tfprintf(file, \"- <a href=\\\"index%c.html\\\">Top20</a> -\", config.tag);\n\n\t\tfor (Counter = 0; Counter < SubnetCount; Counter++)\n\t\t\t{\n\t\t\tHostIp2CharIp(SubnetTable[Counter].ip, Buffer2);\n\t\t\tfprintf(file, \"- <a href=\\\"Subnet-%c-%s.html\\\">%s</a> -\", config.tag, Buffer2, Buffer2);\n\t\t\t}\n\n\t\tfprintf(file, \"<H1>%s - %s</H1></center>\", Buffer1, PeriodDesc);\n\t\tfprintf(file, \"<table width=\\\"100%%\\\" border=1 cellspacing=0>\\n\");\n\n        // PASS 1:  Write out the table\n\n\t\tfprintf(file, \"<TR bgcolor=lightblue><TD>Ip and Name<TD align=center>Total<TD align=center>Total Sent<TD align=center>Total Received<TD align=center>FTP<TD align=center>HTTP<TD align=center>P2P<TD align=center>TCP<TD align=center>UDP<TD align=center>ICMP\\n\");\n\t\tfor (tCounter=0, Counter=0; Counter < NumIps; Counter++)\n\t\t\t{\n            if (SubnetTable[SubnetCounter].ip == (SummaryData[Counter]->IP & SubnetTable[SubnetCounter].mask))\n\t\t\t\t{ // The ip belongs to this subnet\n\t\t\t\tPrintTableLine(file, SummaryData[Counter], tCounter++);\n    \t\t\t}\n\t\t\t}\n\n\t\tfprintf(file, \"</table>\\n\");\n\n\t\t// PASS 2: The graphs\n\t\tfor (Counter=0; Counter < NumIps; Counter++)\n\t\t\t{\n            if (SubnetTable[SubnetCounter].ip == (SummaryData[Counter]->IP & SubnetTable[SubnetCounter].mask))\n\t\t\t\t{ // The ip belongs to this subnet\n\t\t\t\tif (SummaryData[Counter]->Graph)\n\t\t\t\t\t{\n\t\t\t\t\tHostIp2CharIp(SummaryData[Counter]->IP, Buffer1);\n\t\t\t\t\trdns(HostName, SummaryData[Counter]->IP);\n\t\t\t\t\tfprintf(file, \"<a name=\\\"%s-%c\\\"></a><H1><a href=\\\"#top\\\">(Top)</a> %s - %s</H1><BR>\\nSend:<br>\\n<img src=%s-%c-S.png ALT=\\\"Sent traffic graph for %s\\\"><BR>\\n<img src=legend.gif ALT=\\\"Legend\\\"><br>\\nReceived:<br>\\n<img src=%s-%c-R.png ALT=\\\"Received traffic for %s\\\"><BR>\\n<img src=legend.gif ALT=\\\"Legend\\\"><br>\\n<BR>\\n\", Buffer1, config.tag, Buffer1, HostName, Buffer1, config.tag, Buffer1, Buffer1, config.tag, Buffer1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tfprintf(file, \"</BODY></HTML>\\n\");\n\t\tfclose(file);\n\t\t}\n\n\tfree(SummaryData);\n\t}\n\nvoid GraphIp(struct IPDataStore *DataStore, struct SummaryData *SummaryData, time_t timestamp)\n    {\n    FILE *OutputFile;\n    char outputfilename[50];\n    gdImagePtr im, im2;\n    int white;\n    unsigned long long int YMax;\n\tchar CharIp[20];\n\n    time_t GraphBeginTime;\n\n\t// TODO: First determine if graph will be printed before creating image and drawing backround, etc\n\n\tif (DataStore->ip == 0)\n\t\tstrcpy(CharIp, \"Total\");\n\telse\n\t\tHostIp2CharIp(DataStore->ip, CharIp);\n\n    GraphBeginTime = timestamp - config.range;\n\n    im = gdImageCreate(XWIDTH, YHEIGHT);\n    white = gdImageColorAllocate(im, 255, 255, 255);\n    //gdImageFill(im, 10, 10, white);\n\n    im2 = gdImageCreate(XWIDTH, YHEIGHT);\n    white = gdImageColorAllocate(im2, 255, 255, 255);\n    //gdImageFill(im2, 10, 10, white);\n\n    YMax = GraphData(im, im2, DataStore, GraphBeginTime, SummaryData);\n    if (YMax != 0)\n        {\n        // Finish the graph\n        PrepareXAxis(im, timestamp);\n        PrepareYAxis(im, YMax);\n\n        PrepareXAxis(im2, timestamp);\n        PrepareYAxis(im2, YMax);\n\n        sprintf(outputfilename, \"./htdocs/%s-%c-S.png\", CharIp, config.tag);\n        OutputFile = fopen(outputfilename, \"wb\");    \n        gdImagePng(im, OutputFile);\n        fclose(OutputFile);\n\n        sprintf(outputfilename, \"./htdocs/%s-%c-R.png\", CharIp, config.tag);\n        OutputFile = fopen(outputfilename, \"wb\");\n        gdImagePng(im2, OutputFile);\n        fclose(OutputFile);\n        }\n    else\n        {\n        // The graph isn't worth clutering up the web pages with\n        sprintf(outputfilename, \"./htdocs/%s-%c-R.png\", CharIp, config.tag);\n        unlink(outputfilename);\n        sprintf(outputfilename, \"./htdocs/%s-%c-S.png\", CharIp, config.tag);\n        unlink(outputfilename);\n        }\n\n\tgdImageDestroy(im);\n\tgdImageDestroy(im2);\n    }\n\n// Returns YMax\nunsigned long long int GraphData(gdImagePtr im, gdImagePtr im2, struct IPDataStore *DataStore, time_t timestamp, struct SummaryData *SummaryData)\n    {\n    unsigned long long int YMax=0;\n\t\n\tstruct DataStoreBlock *CurrentBlock;\n    struct IPData *Data;\n\n\t// TODO: These should be a structure!!!!\n\t// TODO: This is an awfull lot of data to be allocated on the stack\n\n    unsigned long long total[XWIDTH];\n    unsigned long long icmp[XWIDTH];\n    unsigned long long udp[XWIDTH];\n    unsigned long long tcp[XWIDTH];\n\tunsigned long long ftp[XWIDTH];\n    unsigned long long http[XWIDTH];\n    unsigned long long p2p[XWIDTH];\n    int Count[XWIDTH];\n\n    unsigned long long total2[XWIDTH];\n    unsigned long long icmp2[XWIDTH];\n    unsigned long long udp2[XWIDTH];\n    unsigned long long tcp2[XWIDTH];\n\tunsigned long long ftp2[XWIDTH];\n    unsigned long long http2[XWIDTH];\n    unsigned long long p2p2[XWIDTH];\n\n    size_t DataPoints;\n    double x;\n    int xint;\n    int Counter;\n    char Buffer[30];\n    char Buffer2[50];\n    \n    int blue, lblue, red, yellow, purple, green, brown, black;\n    int blue2, lblue2, red2, yellow2, purple2, green2, brown2, black2;\n\n\tunsigned long long int SentPeak = 0;\n\tunsigned long long int ReceivedPeak = 0;\n\n    yellow   = gdImageColorAllocate(im, 255, 255, 0);\n    purple   = gdImageColorAllocate(im, 255, 0, 255);\n    green    = gdImageColorAllocate(im, 0, 255, 0);\n    blue     = gdImageColorAllocate(im, 0, 0, 255);\n\tlblue\t = gdImageColorAllocate(im, 128, 128, 255);\n    brown    = gdImageColorAllocate(im, 128, 0, 0);\n    red      = gdImageColorAllocate(im, 255, 0, 0);\n    black \t = gdImageColorAllocate(im, 0, 0, 0);\n    \n    yellow2  = gdImageColorAllocate(im2, 255, 255, 0);\n    purple2   = gdImageColorAllocate(im2, 255, 0, 255);\n    green2   = gdImageColorAllocate(im2, 0, 255, 0);\n    blue2    = gdImageColorAllocate(im2, 0, 0, 255);\n\tlblue2\t = gdImageColorAllocate(im2, 128, 128, 255);\n    brown2   = gdImageColorAllocate(im2, 128, 0, 0);\n    red2     = gdImageColorAllocate(im2, 255, 0, 0);\n    black2   = gdImageColorAllocate(im2, 0, 0, 0);\n\n\tCurrentBlock = DataStore->FirstBlock;\n\tData = CurrentBlock->Data;\n    DataPoints = CurrentBlock->NumEntries;\n\n\tmemset(SummaryData, 0, sizeof(struct SummaryData));\n\tSummaryData->IP = Data[0].ip;\n\t\n    memset(Count, 0, sizeof(Count[0])*XWIDTH);\n\n    memset(total, 0, sizeof(total[0])*XWIDTH);\n    memset(icmp, 0, sizeof(total[0])*XWIDTH);\n    memset(udp, 0, sizeof(total[0])*XWIDTH);\n    memset(tcp, 0, sizeof(total[0])*XWIDTH);\n\tmemset(ftp, 0, sizeof(total[0])*XWIDTH);\n    memset(http, 0, sizeof(total[0])*XWIDTH);\n    memset(p2p, 0, sizeof(total[0])*XWIDTH);\n\n    memset(total2, 0, sizeof(total[0])*XWIDTH);\n    memset(icmp2, 0, sizeof(total[0])*XWIDTH);\n    memset(udp2, 0, sizeof(total[0])*XWIDTH);\n    memset(tcp2, 0, sizeof(total[0])*XWIDTH);\n    memset(ftp2, 0, sizeof(total[0])*XWIDTH);\n    memset(http2, 0, sizeof(total[0])*XWIDTH);\n    memset(p2p2, 0, sizeof(total[0])*XWIDTH);\n\n\t// Change this to just run through all the datapoints we have stored in ram\n\n\t// Sum up the bytes/second\n    while(DataPoints > 0)  // We have data to graph\n        {\n        for (Counter = 0; Counter < DataPoints; Counter++)  // Graph it all\n            {\n            x = (Data[Counter].timestamp-timestamp)*((XWIDTH-XOFFSET)/config.range)+XOFFSET;        \n            xint = x;\n\n            if (xint >= 0 && xint < XWIDTH)\n                {\n                Count[xint]++;\n\t\t\t\t\n\t\t\t\tif (Data[Counter].Send.total > SentPeak)\n\t\t\t\t\tSentPeak = Data[Counter].Send.total;\n       \t        total[xint] += Data[Counter].Send.total;\n           \t    icmp[xint] += Data[Counter].Send.icmp;\n               \tudp[xint] += Data[Counter].Send.udp;\n                tcp[xint] += Data[Counter].Send.tcp;\n\t\t\t\tftp[xint] += Data[Counter].Send.ftp;\n       \t        http[xint] += Data[Counter].Send.http;\n\t\t\t\tp2p[xint] += Data[Counter].Send.p2p;\n\n                if (Data[Counter].Receive.total > ReceivedPeak)\n   \t            \tReceivedPeak = Data[Counter].Receive.total;\n       \t        total2[xint] += Data[Counter].Receive.total;\n           \t    icmp2[xint] += Data[Counter].Receive.icmp;\n               \tudp2[xint] += Data[Counter].Receive.udp;\n                tcp2[xint] += Data[Counter].Receive.tcp;\n\t\t\t\tftp2[xint] += Data[Counter].Receive.ftp;\n       \t        http2[xint] += Data[Counter].Receive.http;\n\t\t\t\tp2p2[xint] += Data[Counter].Receive.p2p;\n                }\n            }\n\n\t\tCurrentBlock = CurrentBlock->Next;\n\t\t\t\n\t\tif (CurrentBlock)\n\t\t\t{\n         \tData = CurrentBlock->Data;\n\t\t\tDataPoints = CurrentBlock->NumEntries;\n\t\t\t}\n\t\telse\n\t\t\tDataPoints = 0;\t\t\n        }\n\n\t// Convert SentPeak and ReceivedPeak from bytes to bytes/second\n\tSentPeak /= config.interval; ReceivedPeak /= config.interval;\n\n    // Preform the Average\n    for(Counter=XOFFSET+1; Counter < XWIDTH; Counter++)\n            {\n            if (Count[Counter] > 0)\n                {\n            \tSummaryData->Total += total[Counter] + total2[Counter];\n\t\t\t\tSummaryData->TotalSent += total[Counter];\n \t\t\t\tSummaryData->TotalReceived += total2[Counter];\n\t\t\t\tSummaryData->TCP += tcp[Counter] + tcp2[Counter];\n\t\t\t\tSummaryData->FTP += ftp[Counter] + ftp2[Counter];\n\t\t\t\tSummaryData->HTTP += http[Counter] + http2[Counter];\n\t\t\t\tSummaryData->P2P += p2p[Counter] + p2p2[Counter];\n\t\t\t\tSummaryData->UDP += udp[Counter] + udp2[Counter];\n\t\t\t\tSummaryData->ICMP += icmp[Counter] + icmp2[Counter];\n\n                // Preform the average\n                total[Counter] /= (Count[Counter]*config.interval);\n                tcp[Counter] /= (Count[Counter]*config.interval);\n                ftp[Counter] /= (Count[Counter]*config.interval);\n                http[Counter] /= (Count[Counter]*config.interval);\n\t\t\t\tp2p[Counter] /= (Count[Counter]*config.interval);\n                udp[Counter] /= (Count[Counter]*config.interval);\n                icmp[Counter] /= (Count[Counter]*config.interval);\n\t\t\t\t\t\t\t\t\n                total2[Counter] /= (Count[Counter]*config.interval);\n                tcp2[Counter] /= (Count[Counter]*config.interval);\n\t\t\t\tftp2[Counter] /= (Count[Counter]*config.interval);\n                http2[Counter] /= (Count[Counter]*config.interval);\n\t\t\t\tp2p2[Counter] /= (Count[Counter]*config.interval);\n                udp2[Counter] /= (Count[Counter]*config.interval);\n                icmp2[Counter] /= (Count[Counter]*config.interval);\n\n\n                if (total[Counter] > YMax)\n                    YMax = total[Counter];\n                \n                if (total2[Counter] > YMax)\n                    YMax = total2[Counter];\n                }\n            }\n\n    YMax += YMax*0.05;    // Add an extra 5%\n\t\n    if ((SummaryData->IP != 0 && SummaryData->Total < config.graph_cutoff))\n\t\t{\n\t\tSummaryData->Graph = FALSE;\n        return(0);\n\t\t}\n\telse\n        SummaryData->Graph = TRUE;\n\n    // Plot the points\n    for(Counter=XOFFSET+1; Counter < XWIDTH; Counter++)    \n            {\n            if (Count[Counter] > 0)\n                {\n                // Convert the bytes/sec to y coords\n                total[Counter] = (total[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                tcp[Counter] = (tcp[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                ftp[Counter] = (ftp[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                http[Counter] = (http[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                p2p[Counter] = (p2p[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                udp[Counter] = (udp[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                icmp[Counter] = (icmp[Counter]*(YHEIGHT-YOFFSET))/YMax;\n\n                total2[Counter] = (total2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                tcp2[Counter] = (tcp2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                ftp2[Counter] = (ftp2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                http2[Counter] = (http2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n\t\t\t\tp2p2[Counter] = (p2p2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                udp2[Counter] = (udp2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n                icmp2[Counter] = (icmp2[Counter]*(YHEIGHT-YOFFSET))/YMax;\n\n                // Stack 'em up!\n                // Total is stacked from the bottom\n                // Icmp is on the bottom too\n                // Udp is stacked on top of icmp\n                udp[Counter] += icmp[Counter];\n\t\t\t\tudp2[Counter] += icmp2[Counter];\n                // TCP and p2p are stacked on top of Udp\n                tcp[Counter] += udp[Counter];\n                tcp2[Counter] += udp2[Counter];\n                p2p[Counter] += udp[Counter];\n                p2p2[Counter] += udp2[Counter];\n\t\t\t\t// Http is stacked on top of p2p\n                http[Counter] += p2p[Counter];\n                http2[Counter] += p2p2[Counter];\n\t\t\t\t// Ftp is stacked on top of http\n                ftp[Counter] += http[Counter];\n                ftp2[Counter] += http2[Counter];\n\n                // Plot them!\n\t\t\t\t// Sent\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - total[Counter], Counter, YHEIGHT-YOFFSET-1, yellow);\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - icmp[Counter], Counter, YHEIGHT-YOFFSET-1, red);\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - udp[Counter], Counter, (YHEIGHT-YOFFSET) - icmp[Counter] - 1, brown);\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - tcp[Counter], Counter, (YHEIGHT-YOFFSET) - udp[Counter] - 1, green);\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - p2p[Counter], Counter, (YHEIGHT-YOFFSET) - udp[Counter] - 1, purple);\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - http[Counter], Counter, (YHEIGHT-YOFFSET) - p2p[Counter] - 1, blue);\n                gdImageLine(im, Counter, (YHEIGHT-YOFFSET) - ftp[Counter], Counter, (YHEIGHT-YOFFSET) - http[Counter] - 1, lblue);\n\t\t\t\t\t\t\t\t\n\t\t\t\t// Receive\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - total2[Counter], Counter, YHEIGHT-YOFFSET-1, yellow2);\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - icmp2[Counter], Counter, YHEIGHT-YOFFSET-1, red2);\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - udp2[Counter], Counter, (YHEIGHT-YOFFSET) - icmp2[Counter] - 1, brown2);\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - tcp2[Counter], Counter, (YHEIGHT-YOFFSET) - udp2[Counter] - 1, green2);\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - p2p2[Counter], Counter, (YHEIGHT-YOFFSET) - udp2[Counter] - 1, purple2);\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - http2[Counter], Counter, (YHEIGHT-YOFFSET) - p2p2[Counter] - 1, blue2);\n                gdImageLine(im2, Counter, (YHEIGHT-YOFFSET) - ftp2[Counter], Counter, (YHEIGHT-YOFFSET) - http2[Counter] - 1, lblue2);\n\n\n                }\n            }\n\n\tif (SentPeak < 1024/8)\n\t\tsnprintf(Buffer2, 50, \"Peak Send Rate: %.1f Bits/sec\", (double)SentPeak*8);\n\telse if (SentPeak < (1024*1024)/8)\n\t\tsnprintf(Buffer2, 50, \"Peak Send Rate: %.1f KBits/sec\", ((double)SentPeak*8.0)/1024.0);\n\telse snprintf(Buffer2, 50, \"Peak Send Rate: %.1f MBits/sec\", ((double)SentPeak*8.0)/(1024.0*1024.0));\n\t\t\t\t\t\t\t\t\n\tif (SummaryData->TotalSent < 1024)\n\t\tsnprintf(Buffer, 30, \"Sent %.1f Bytes\", (double)SummaryData->TotalSent);\t\t\t\t\t\n\telse if (SummaryData->TotalSent < 1024*1024)\n\t\tsnprintf(Buffer, 30, \"Sent %.1f KBytes\", (double)SummaryData->TotalSent/1024.0);\n\telse snprintf(Buffer, 30, \"Sent %.1f MBytes\", (double)SummaryData->TotalSent/(1024.0*1024.0));\n\n\tgdImageString(im, gdFontSmall, XOFFSET+5,  YHEIGHT-20, Buffer, black);\n\tgdImageString(im, gdFontSmall, XWIDTH/2+XOFFSET/2,  YHEIGHT-20, Buffer2, black);\t\t\t\t\n\n\tif (ReceivedPeak < 1024/8)\n       \tsnprintf(Buffer2, 50, \"Peak Receive Rate: %.1f Bits/sec\", (double)ReceivedPeak*8);\n    else if (ReceivedPeak < (1024*1024)/8)\n    \tsnprintf(Buffer2, 50, \"Peak Receive Rate: %.1f KBits/sec\", ((double)ReceivedPeak*8.0)/1024.0);               \n\telse snprintf(Buffer2, 50, \"Peak Receive Rate: %.1f MBits/sec\", ((double)ReceivedPeak*8.0)/(1024.0*1024.0));\n\n    if (SummaryData->TotalReceived < 1024)\n        snprintf(Buffer, 30, \"Received %.1f Bytes\", (double)SummaryData->TotalReceived);\n    else if (SummaryData->TotalReceived < 1024*1024)\n        snprintf(Buffer, 30, \"Received %.1f KBytes\", (double)SummaryData->TotalReceived/1024.0);\n    else snprintf(Buffer, 30, \"Received %.1f MBytes\", (double)SummaryData->TotalReceived/(1024.0*1024.0));\n                                                                                                              \n    gdImageString(im2, gdFontSmall, XOFFSET+5,  YHEIGHT-20, Buffer, black2);                \n    gdImageString(im2, gdFontSmall, XWIDTH/2+XOFFSET/2,  YHEIGHT-20, Buffer2, black2);\n\n    return(YMax);\n    }\n\nvoid PrepareYAxis(gdImagePtr im, unsigned long long int YMax)\n    {\n    char buffer[20];\n\n\tchar YLegend;\n\tlong long int Divisor;\n\n    int black;\n    float YTic = 0;\n    double y;\n    long int YStep;\n    \n    black = gdImageColorAllocate(im, 0, 0, 0);\n    gdImageLine(im, XOFFSET, 0, XOFFSET, YHEIGHT, black);\n\n    YLegend = ' ';\n    Divisor = 1;\n    if (YMax*8 > 1024*2)\n        {\n        Divisor = 1024;    // Display in K\n        YLegend = 'k';\n        }\n    if (YMax*8 > 1024*1024*2)\n        {\n        Divisor = 1024*1024; // Display in M\n        YLegend = 'm';\n        }\n    if (YMax*8 > (long long)1024*1024*1024*2)\n        {\n        Divisor = 1024*1024*1024; // Display in G\n        YLegend = 'g';\n        }\n\n    YStep = YMax/10;\n    if (YStep < 1)\n        YStep=1;\n    YTic=YStep;\n\n    while (YTic < (YMax - YMax/10))\n        {\n        y = (YHEIGHT-YOFFSET)-((YTic*(YHEIGHT-YOFFSET))/YMax);        \n\n        gdImageLine(im, XOFFSET, y, XWIDTH, y, black);        \n        snprintf(buffer, 20, \"%4.1f %cbits/s\", (float)(8.0*YTic)/Divisor, YLegend);\n        gdImageString(im, gdFontSmall, 3, y-7, buffer, black);        \n\n        YTic += YStep;\n        }\n    } \n\nvoid PrepareXAxis(gdImagePtr im, time_t timestamp)\n    {\n    char buffer[100];\n    int black, red;\n    time_t sample_begin, sample_end;    \n    struct tm *timestruct;\n    long int MarkTime;\n\tlong int MarkTimeStep;\n    double x;\n    \n    sample_begin=timestamp-config.range;\n    sample_end=sample_begin+config.interval;\n\n    black = gdImageColorAllocate(im, 0, 0, 0);\n    red   = gdImageColorAllocate(im, 255, 0, 0);\n\n    gdImageLine(im, 0, YHEIGHT-YOFFSET, XWIDTH, YHEIGHT-YOFFSET, black);\n\n    // ********************************************************************\n    // ****  Write the red day/month seperator bars\n    // ********************************************************************\n\n\tif ((24*60*60*(XWIDTH-XOFFSET))/config.range > (XWIDTH-XOFFSET)/10)\n\t\t{\n\t\t// Day bars\n\t    timestruct = localtime((time_t *)&sample_begin);\n    \ttimestruct->tm_sec = 0;\n\t    timestruct->tm_min = 0;\n    \ttimestruct->tm_hour = 0;\n\t    MarkTime = mktime(timestruct);\n            \n    \tx = (MarkTime-sample_begin)*( ((double)(XWIDTH-XOFFSET)) / config.range) + XOFFSET;\n\t    while (x < XOFFSET)\n    \t    {\n        \tMarkTime += (24*60*60);\n\t        x = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n    \t    }\n\n\t    while (x < (XWIDTH-10))\n    \t    {\n        \t// Day Lines\n\t        gdImageLine(im, x, 0, x, YHEIGHT-YOFFSET, red);\n    \t    gdImageLine(im, x+1, 0, x+1, YHEIGHT-YOFFSET, red);\n\t\n    \t    timestruct = localtime((time_t *)&MarkTime);\n\t        strftime(buffer, 100, \"%a, %b %d\", timestruct);\n    \t    gdImageString(im, gdFontSmall, x-30,  YHEIGHT-YOFFSET+10, buffer, black);        \n\n\t        // Calculate Next x\n    \t    MarkTime += (24*60*60);\n        \tx = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n\t        }\n\t\t}\n\telse\n\t\t{\n    \t// Month Bars\n        timestruct = localtime((time_t *)&sample_begin);\n        timestruct->tm_sec = 0;\n        timestruct->tm_min = 0;\n        timestruct->tm_hour = 0;\n\t\ttimestruct->tm_mday = 1;\n\t\ttimestruct->tm_mon--; // Start the month before the sample\n        MarkTime = mktime(timestruct);\n\n    \tx = (MarkTime-sample_begin)*( ((double)(XWIDTH-XOFFSET)) / config.range) + XOFFSET;\n\t    while (x < XOFFSET)\n    \t    {\n\t\t\ttimestruct->tm_mon++;\n        \tMarkTime = mktime(timestruct);\n\t        x = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n    \t    }\n\n\t    while (x < (XWIDTH-10))\n    \t    {\n        \t// Month Lines\n\t        gdImageLine(im, x, 0, x, YHEIGHT-YOFFSET, red);\n    \t    gdImageLine(im, x+1, 0, x+1, YHEIGHT-YOFFSET, red);\n\t\n    \t    timestruct = localtime((time_t *)&MarkTime);\n\t        strftime(buffer, 100, \"%b\", timestruct);\n    \t    gdImageString(im, gdFontSmall, x-6,  YHEIGHT-YOFFSET+10, buffer, black);        \n\n\t        // Calculate Next x\n            timestruct->tm_mon++;\n            MarkTime = mktime(timestruct);\n        \tx = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n\t        }\t\t\t\t\n\t\t}\n\n    // ********************************************************************\n    // ****  Write the tic marks\n    // ********************************************************************\n\n    timestruct = localtime((time_t *)&sample_begin);\n    timestruct->tm_sec = 0;\n    timestruct->tm_min = 0;\n    timestruct->tm_hour = 0;\n    MarkTime = mktime(timestruct);\n\n\tif ((6*60*60*(XWIDTH-XOFFSET))/config.range > 10) // pixels per 6 hours is more than 2\n\t\tMarkTimeStep = 6*60*60; // Major ticks are 6 hours\n\telse if ((24*60*60*(XWIDTH-XOFFSET))/config.range > 10)\n\t\tMarkTimeStep = 24*60*60; // Major ticks are 24 hours;\n\telse\n\t\treturn; // Done\t\t\n\n\tx = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n\twhile (x < XOFFSET)\n   \t\t{\n\t\tMarkTime += MarkTimeStep;\n\t    x = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n    \t}\n\n    while (x < (XWIDTH-10))\n    \t{\n\t    if (x > XOFFSET) {\n    \t\tgdImageLine(im, x, YHEIGHT-YOFFSET-5, x, YHEIGHT-YOFFSET+5, black);\n\t       \tgdImageLine(im, x+1, YHEIGHT-YOFFSET-5, x+1, YHEIGHT-YOFFSET+5, black);\n        \t}\n\t\tMarkTime += MarkTimeStep;\n   \t\tx = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n        }\n\n    timestruct = localtime((time_t *)&sample_begin);\n    timestruct->tm_sec = 0;\n    timestruct->tm_min = 0;\n    timestruct->tm_hour = 0;\n    MarkTime = mktime(timestruct);\n\n\tif ((60*60*(XWIDTH-XOFFSET))/config.range > 2) // pixels per hour is more than 2\n\t\tMarkTimeStep = 60*60;  // Minor ticks are 1 hour\n\telse if ((6*60*60*(XWIDTH-XOFFSET))/config.range > 2)\n\t\tMarkTimeStep = 6*60*60; // Minor ticks are 6 hours\n\telse if ((24*60*60*(XWIDTH-XOFFSET))/config.range > 2)\n\t\tMarkTimeStep = 24*60*60;\n\telse\n\t\treturn; // Done\n\n\t// Draw Minor Tic Marks\n\tx = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n\n\twhile (x < XOFFSET)\n   \t\t{\n\t\tMarkTime += MarkTimeStep;\n\t    x = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n    \t}\n\n    while (x < (XWIDTH-10))\n        {\n\t    if (x > XOFFSET) {\n    \t\tgdImageLine(im, x, YHEIGHT-YOFFSET, x, YHEIGHT-YOFFSET+5, black);\n        \tgdImageLine(im, x+1, YHEIGHT-YOFFSET, x+1, YHEIGHT-YOFFSET+5, black);\n            }\n\t    MarkTime+=MarkTimeStep;\n    \tx = (MarkTime-sample_begin)*((XWIDTH-XOFFSET)/config.range) + XOFFSET;\n        }\n    }\n\n",
			"file": "graph.c",
			"file_size": 33795,
			"file_write_time": 133378134238544837,
			"settings":
			{
				"buffer_size": 33794,
				"encoding": "UTF-8",
				"line_ending": "Unix"
			},
			"undo_stack":
			[
				[
					5,
					1,
					"insert",
					{
						"characters": "\n"
					},
					"AgAAAP4PAAAAAAAA/w8AAAAAAAAAAAAA/w8AAAAAAAAAEAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA/g8AAAAAAAD+DwAAAAAAAAAAAAAAAPC/"
				],
				[
					8,
					1,
					"insert",
					{
						"characters": "char"
					},
					"BAAAAAAQAAAAAAAAARAAAAAAAAAAAAAAARAAAAAAAAACEAAAAAAAAAAAAAACEAAAAAAAAAMQAAAAAAAAAAAAAAMQAAAAAAAABBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAABAAAAAAAAAAEAAAAAAAAAAAAAAAAPC/"
				],
				[
					9,
					1,
					"insert",
					{
						"characters": " bu"
					},
					"AwAAAAQQAAAAAAAABRAAAAAAAAAAAAAABRAAAAAAAAAGEAAAAAAAAAAAAAAGEAAAAAAAAAcQAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABBAAAAAAAAAEEAAAAAAAAAAAAAAAAPC/"
				],
				[
					10,
					2,
					"left_delete",
					null,
					"AgAAAAYQAAAAAAAABhAAAAAAAAABAAAAdQUQAAAAAAAABRAAAAAAAAABAAAAYg",
					"AQAAAAAAAAABAAAABxAAAAAAAAAHEAAAAAAAAAAAAAAAAPC/"
				],
				[
					11,
					1,
					"insert",
					{
						"characters": "Buffer"
					},
					"BgAAAAUQAAAAAAAABhAAAAAAAAAAAAAABhAAAAAAAAAHEAAAAAAAAAAAAAAHEAAAAAAAAAgQAAAAAAAAAAAAAAgQAAAAAAAACRAAAAAAAAAAAAAACRAAAAAAAAAKEAAAAAAAAAAAAAAKEAAAAAAAAAsQAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAABRAAAAAAAAAFEAAAAAAAAAAAAAAAAPC/"
				],
				[
					12,
					1,
					"insert",
					{
						"characters": "1b"
					},
					"AgAAAAsQAAAAAAAADBAAAAAAAAAAAAAADBAAAAAAAAANEAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAACxAAAAAAAAALEAAAAAAAAAAAAAAAAPC/"
				],
				[
					13,
					1,
					"insert_snippet",
					{
						"contents": "[$0]"
					},
					"AQAAAA0QAAAAAAAADxAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADRAAAAAAAAANEAAAAAAAAAAAAAAAAPC/"
				],
				[
					15,
					1,
					"insert",
					{
						"characters": "5"
					},
					"AQAAAA4QAAAAAAAADxAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADhAAAAAAAAAOEAAAAAAAAAAAAAAAAPC/"
				],
				[
					17,
					1,
					"insert",
					{
						"characters": "0"
					},
					"AQAAAA8QAAAAAAAAEBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADxAAAAAAAAAPEAAAAAAAAAAAAAAAAPC/"
				],
				[
					20,
					1,
					"insert",
					{
						"characters": ";"
					},
					"AQAAABEQAAAAAAAAEhAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAERAAAAAAAAAREAAAAAAAAAAAAAAAAPC/"
				],
				[
					25,
					1,
					"toggle_comment",
					{
						"block": false
					},
					"AQAAAMEQAAAAAAAAxBAAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAA1RAAAAAAAADVEAAAAAAAAAAAAAAAAPC/"
				],
				[
					54,
					1,
					"",
					null,
					"AgAAAK0RAAAAAAAAthEAAAAAAAAAAAAAthEAAAAAAAC2EQAAAAAAAAoAAABJUEhvc3ROYW1l",
					"AQAAAAAAAAABAAAArREAAAAAAAC3EQAAAAAAAAAAAAAAAPC/"
				],
				[
					57,
					1,
					"right_delete",
					null,
					"AQAAALYRAAAAAAAAthEAAAAAAAABAAAALA",
					"AQAAAAAAAAABAAAAthEAAAAAAAC2EQAAAAAAAAAAAAAAAPC/"
				],
				[
					71,
					1,
					"insert",
					{
						"characters": "//"
					},
					"AgAAAA0SAAAAAAAADhIAAAAAAAAAAAAADhIAAAAAAAAPEgAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAADRIAAAAAAAANEgAAAAAAAAAAAAAAAPC/"
				],
				[
					77,
					1,
					"",
					null,
					"AgAAAAAAAAAAAAAAA4QAAAAAAAAAAAAAA4QAAAAAAAADhAAAAAAAAI+CAAAjaW5jbHVkZSA8dW5pc3RkLmg+CiNpbmNsdWRlIDxzZXRqbXAuaD4KI2luY2x1ZGUgPHNpZ25hbC5oPgojaW5jbHVkZSA8c3RyaW5nLmg+CiNpbmNsdWRlIDxuZXRkYi5oPgojaW5jbHVkZSA8bmV0aW5ldC9pbi5oPgoKI2luY2x1ZGUgPHN5cy90eXBlcy5oPgojaW5jbHVkZSA8c3lzL3NvY2tldC5oPgoKI2luY2x1ZGUgPHRpbWUuaD4KI2luY2x1ZGUgImJhbmR3aWR0aGQuaCIKCiNpZmRlZiBIQVZFX0FSUEFfTkFNRVNFUl9ICiNpbmNsdWRlIDxhcnBhL25hbWVzZXIuaD4KI2VuZGlmCiNpZmRlZiBIQVZFX1JFU09MVl9ICiNpbmNsdWRlIDxyZXNvbHYuaD4KI2VuZGlmCgpleHRlcm4gdW5zaWduZWQgaW50IFN1Ym5ldENvdW50OwpleHRlcm4gc3RydWN0IGNvbmZpZyBjb25maWc7CgpqbXBfYnVmIGRuc2p1bXA7CgpzdGF0aWMgdm9pZCByZG5zbG5nam1wKGludCBzaWduYWwpOwoKdm9pZCByZG5zKGNoYXIgKkJ1ZmZlciwgdW5zaWduZWQgbG9uZyBJUCkgIC8vIFRoaXMgdGFrZXMgb3ZlciBzaWdhbGFybSEKCXsKI2lmZGVmIEhBVkVfUkVTT0xWX0gKCWNoYXIgRE5TRXJyb3JbXSA9ICJETlMgVGltZW91dDogQ29ycmVjdCB0byBzcGVlZCB1cCBncmFwaGluZyI7CgljaGFyIE5vbmVbXSA9ICJDb25maWd1cmUgRE5TIHRvIHJldmVyc2UgdGhpcyBJUCI7CgljaGFyIFRvb01hbnlETlNUaW1lb3V0c1tdID0gIlRvbyBtYW55IGRucyB0aW1lb3V0cywgcmV2ZXJzZSBsb29rdXBzIHN1c3BlbmRlZCI7CglzdHJ1Y3QgaG9zdGVudCAqaG9zdGVudDsKCWNoYXIgY2hySVBbNTBdOwoJc3RhdGljIGludCBJbml0ID0gVFJVRTsKCXN0YXRpYyBpbnQgRE5TVGltZW91dHMgPSAwOyAgLy8gVGhpcyBpcyByZXNldCBmb3IgZWFjaCBydW4gYmVjYXVzZSB3ZSdyZSBmb3JrZWQKCXVuc2lnbmVkIGxvbmcgYWRkciA9IGh0b25sKElQKTsKCiAgICBfcmVzLnJldHJhbnMgPSAxOwogICAgX3Jlcy5yZXRyeSA9IDI7CgoJaWYgKEluaXQpCgkJewogICAgICAgIHNpZ25hbChTSUdBTFJNLCByZG5zbG5nam1wKTsKCQlJbml0ID0gRkFMU0U7CgkJfQoKCWlmIChETlNUaW1lb3V0cyA+IDEwMCkKCQl7CgkJc3lzbG9nKExPR19FUlIsICJUb28gbWFueSBkbnMgdGltZW91dHMsIHJldmVyc2UgbG9va3VwcyBzdXNwZW5kZWQiKTsKICAgICAgICBzdHJuY3B5KEJ1ZmZlciwgVG9vTWFueUROU1RpbWVvdXRzLCAyNTMpOwoJCUJ1ZmZlclsyNTRdID0gJ1wwJzsKCQlyZXR1cm47CgkJfQkJCgoJaWYgKHNldGptcChkbnNqdW1wKSA9PSAwKQoJCXsKCQlhbGFybSgxMCk7ICAvLyBEb24ndCBsZXQgZ2V0aG9zdGJ5YWRkciBob2xkIHVzIHVwIHRvbyBsb25nCgkJaG9zdGVudCA9IGdldGhvc3RieWFkZHIoKGNoYXIgKikgJmFkZHIsIDQsIEFGX0lORVQpOyAvLyAoY2hhciAqKSZEYXRhLT5JUAkJCQkKCQlhbGFybSgwKTsKCQkKCQlpZiAoaG9zdGVudCkKCQkJc3ByaW50ZihCdWZmZXIsICIlcyIsIGhvc3RlbnQtPmhfbmFtZSk7CgkJZWxzZQoJCQl7CgkgICAgICAgIHN0cm5jcHkoQnVmZmVyLCBOb25lLCAyNTMpOwoJCQlCdWZmZXJbMjU0XSA9ICdcMCc7CgkJCX0KCQl9CgllbHNlICAvLyBPdXIgYWxhcm0gdGltZWQgb3V0CgkJewoJCUhvc3RJcDJDaGFySXAoSVAsIGNocklQKTsKCQlzeXNsb2coTE9HX0VSUiwgIkROUyB0aW1lb3V0IGZvciAlczogVGhpcyBwcm9ibGVtIHJlZHVjZXMgZ3JhcGhpbmcgcGVyZm9ybWFuY2UiLCBjaHJJUCk7CgkJRE5TVGltZW91dHMrKzsKICAgICAgICBzdHJuY3B5KEJ1ZmZlciwgRE5TRXJyb3IsIDI1Myk7CgkJQnVmZmVyWzI1NF0gPSAnXDAnOwoJCX0KI2Vsc2UKCUJ1ZmZlclswXSA9ICdcMCc7CiNlbmRpZgoJfQoKc3RhdGljIHZvaWQgcmRuc2xuZ2ptcChpbnQgc2lnbmFsKQoJewogICAgbG9uZ2ptcChkbnNqdW1wLCAxKTsKCX0KCnZvaWQgc3dhcChzdHJ1Y3QgU3VtbWFyeURhdGEgKiphLCBzdHJ1Y3QgU3VtbWFyeURhdGEgKipiKSB7CglzdHJ1Y3QgU3VtbWFyeURhdGEgKnRlbXA7CiAgICB0ZW1wID0gKmE7ICphID0gKmI7ICpiID0gdGVtcDsKfQp2b2lkIFF1aWNrU29ydFN1bW1hcnlEYXRhKHN0cnVjdCBTdW1tYXJ5RGF0YSAqU3VtbWFyeURhdGFbXSwgaW50IGxlZnQsIGludCByaWdodCkgewogICAgaW50IGksaixjZW50ZXI7CiAgICB1bnNpZ25lZCBsb25nIGxvbmcgcGl2b3Q7CiAgICBpZiAobGVmdD09cmlnaHQpIHJldHVybjsKICAgIGlmIChsZWZ0KzE9PXJpZ2h0KSB7CiAgICAgICAgaWYgKFN1bW1hcnlEYXRhW2xlZnRdLT5Ub3RhbCA8IFN1bW1hcnlEYXRhW3JpZ2h0XS0+VG90YWwpCiAgICAgICAgICAgIHN3YXAoJlN1bW1hcnlEYXRhW2xlZnRdLCZTdW1tYXJ5RGF0YVtyaWdodF0pOwogICAgICAgIHJldHVybjsKICAgIH0KICAgIC8qIHVzZSB0aGUgbWVkaWFuLW9mLXRocmVlIG1ldGhvZCBmb3IgcGlja2luZyBwaXZvdCAqLwogICAgY2VudGVyID0gKGxlZnQrcmlnaHQpLzI7CiAgICBpZiAoU3VtbWFyeURhdGFbbGVmdF0tPlRvdGFsIDwgU3VtbWFyeURhdGFbY2VudGVyXS0+VG90YWwpCiAgICAgICAgc3dhcCgmU3VtbWFyeURhdGFbbGVmdF0sJlN1bW1hcnlEYXRhW2NlbnRlcl0pOwogICAgaWYgKFN1bW1hcnlEYXRhW2xlZnRdLT5Ub3RhbCA8IFN1bW1hcnlEYXRhW3JpZ2h0XS0+VG90YWwpCiAgICAgICAgc3dhcCgmU3VtbWFyeURhdGFbbGVmdF0sJlN1bW1hcnlEYXRhW3JpZ2h0XSk7CiAgICBpZiAoU3VtbWFyeURhdGFbY2VudGVyXS0+VG90YWwgPCBTdW1tYXJ5RGF0YVtyaWdodF0tPlRvdGFsKQogICAgICAgIHN3YXAoJlN1bW1hcnlEYXRhW2NlbnRlcl0sJlN1bW1hcnlEYXRhW3JpZ2h0XSk7CiAgICBwaXZvdCA9IFN1bW1hcnlEYXRhW2NlbnRlcl0tPlRvdGFsOwogICAgc3dhcCgmU3VtbWFyeURhdGFbY2VudGVyXSwmU3VtbWFyeURhdGFbcmlnaHQtMV0pOyAvKiBoaWRlIHRoZSBwaXZvdCAqLwogICAgaSA9IGxlZnQ7IGogPSByaWdodCAtIDE7CiAgICBkbyB7CiAgICAgICAgZG8geyArK2k7IH0gd2hpbGUgKFN1bW1hcnlEYXRhW2ldLT5Ub3RhbCA+IHBpdm90KTsKICAgICAgICBkbyB7IC0tajsgfSB3aGlsZSAoU3VtbWFyeURhdGFbal0tPlRvdGFsIDwgcGl2b3QpOwogICAgICAgIHN3YXAoJlN1bW1hcnlEYXRhW2ldLCZTdW1tYXJ5RGF0YVtqXSk7CiAgICB9IHdoaWxlIChqID4gaSk7CiAgICBzd2FwKCZTdW1tYXJ5RGF0YVtpXSwmU3VtbWFyeURhdGFbal0pOyAvKiB1bmRvIGxhc3Qgc3dhcCAqLwogICAgc3dhcCgmU3VtbWFyeURhdGFbaV0sJlN1bW1hcnlEYXRhW3JpZ2h0LTFdKTsgLyogcmVzdG9yZSBwaXZvdCAqLwogICAgUXVpY2tTb3J0U3VtbWFyeURhdGEoU3VtbWFyeURhdGEsbGVmdCxpLTEpOwogICAgUXVpY2tTb3J0U3VtbWFyeURhdGEoU3VtbWFyeURhdGEsaSsxLHJpZ2h0KTsKfQoKI2RlZmluZSBOdW1GYWN0b3IgMTAyNApzdGF0aWMgdm9pZCBGb3JtYXROdW0odW5zaWduZWQgbG9uZyBsb25nIG4sIGNoYXIgKmJ1ZiwgaW50IGxlbikgewogICAgZG91YmxlIGY7CiAgICBpZiAobjxOdW1GYWN0b3IpIHsgc25wcmludGYoYnVmLGxlbiwiPHRkIGFsaWduPVwicmlnaHRcIj48dHQ+JWkmbmJzcDs8L3R0PjwvdGQ+IiwoaW50KW4pOyByZXR1cm47IH0KICAgIGYgPSBuOwogICAgZiAvPSBOdW1GYWN0b3I7IGlmIChmPE51bUZhY3RvcikgeyBzbnByaW50ZihidWYsbGVuLCI8dGQgYWxpZ249XCJyaWdodFwiPjx0dD4lLjFmSzwvdHQ+PC90ZD4iLGYpOyByZXR1cm47IH0KICAgIGYgLz0gTnVtRmFjdG9yOyBpZiAoZjxOdW1GYWN0b3IpIHsgc25wcmludGYoYnVmLGxlbiwiPHRkIGFsaWduPVwicmlnaHRcIj48dHQ+JS4xZk08L3R0PjwvdGQ+IixmKTsgcmV0dXJuOyB9CiAgICBmIC89IE51bUZhY3RvcjsgaWYgKGY8TnVtRmFjdG9yKSB7IHNucHJpbnRmKGJ1ZixsZW4sIjx0ZCBhbGlnbj1cInJpZ2h0XCI+PHR0PiUuMWZHPC90dD48L3RkPiIsZik7IHJldHVybjsgfQogICAgZiAvPSBOdW1GYWN0b3I7IHNucHJpbnRmKGJ1ZixsZW4sIjx0ZCBhbGlnbj1cInJpZ2h0XCI+PHR0PiUuMWZUPC90dD48L3RkPlxuIixmKTsKfQoKdm9pZCBQcmludFRhYmxlTGluZShGSUxFICpzdHJlYW0sIHN0cnVjdCBTdW1tYXJ5RGF0YSAqRGF0YSwgaW50IENvdW50ZXIpCgl7CgljaGFyIEJ1ZmZlcjFbNTBdOwoJY2hhciBCdWZmZXIxYls1MF07CgljaGFyIEJ1ZmZlcjJbNTBdOwoJY2hhciBCdWZmZXIzWzUwXTsKCWNoYXIgQnVmZmVyNFs1MF07CgljaGFyIEJ1ZmZlcjRiWzUwXTsKCWNoYXIgQnVmZmVyNVs1MF07CgljaGFyIEJ1ZmZlcjViWzUwXTsKCWNoYXIgQnVmZmVyNls1MF07CgljaGFyIEJ1ZmZlcjdbNTBdOwoJY2hhciBCdWZmZXI4WzUwXTsKCS8vIGNoYXIgSVBIb3N0TmFtZVs1MF07CgoKCS8vIEZpcnN0IGNvbnZlcnQgdGhlIGluZm8gdG8gbmljZSwgaHVtYW4gcmVhZGFibGUgc3R1ZmYKCXJkbnMoSVBIb3N0TmFtZSwgRGF0YS0+SVApOwoJaWYgKERhdGEtPklQID09IDApCgkJc3RyY3B5KEJ1ZmZlcjEsICJUb3RhbCIpOwoJLy8gRm9yIDAsIHRoZSB0b3RhbHMgcm93LCB0aGUgb3V0cHV0IG9mIHJkbnMgd2lsbCBiZSBvdmVyd3JpdHRlbi4KCQlzdHJjcHkoQnVmZmVyMWIsICIiKTsgCgllbHNlCgkJSG9zdElwMkNoYXJJcChEYXRhLT5JUCwgQnVmZmVyMSk7CiAgICAgICAgc3RyY2F0KEJ1ZmZlcjEsICItIik7CiAgICAgICAgLy9zdHJjYXQoQnVmZmVyMSwgSVBIb3N0TmFtZSk7CgoKICAgIEZvcm1hdE51bShEYXRhLT5Ub3RhbCwgICAgICAgICBCdWZmZXIyLCAgNTApOwoJRm9ybWF0TnVtKERhdGEtPlRvdGFsU2VudCwgICAgIEJ1ZmZlcjMsICA1MCk7CglGb3JtYXROdW0oRGF0YS0+VG90YWxSZWNlaXZlZCwgQnVmZmVyNCwgIDUwKTsKCUZvcm1hdE51bShEYXRhLT5GVFAsIAkJICAgQnVmZmVyNGIsIDUwKTsKCUZvcm1hdE51bShEYXRhLT5IVFRQLCAgICAgICAgICBCdWZmZXI1LCAgNTApOwoJRm9ybWF0TnVtKERhdGEtPlAyUCwgICAgICAgICAgIEJ1ZmZlcjViLCA1MCk7CglGb3JtYXROdW0oRGF0YS0+VENQLCAgICAgICAgICAgQnVmZmVyNiwgIDUwKTsKCUZvcm1hdE51bShEYXRhLT5VRFAsICAgICAgICAgICBCdWZmZXI3LCAgNTApOwoJRm9ybWF0TnVtKERhdGEtPklDTVAsICAgICAgICAgIEJ1ZmZlcjgsICA1MCk7CgoJaWYgKENvdW50ZXIlNCA9PSAwIHx8IChDb3VudGVyLTEpJTQgPT0gMCkKCQlmcHJpbnRmKHN0cmVhbSwgIjxUUj4iKTsKCWVsc2UKCQlmcHJpbnRmKHN0cmVhbSwgIjxUUiBiZ2NvbG9yPWxpZ2h0Ymx1ZT4iKTsKCglpZiAoRGF0YS0+R3JhcGgpCgkJZnByaW50ZihzdHJlYW0sICI8VEQ+PGEgaHJlZj1cIiMlcy0lY1wiPiVzPC9hPjwvVEQ+JXMlcyVzJXMlcyVzJXMlcyVzPC9UUj5cbiIsCgkJCUJ1ZmZlcjEsIC8vIElwCgkJCWNvbmZpZy50YWcsCgkJCUJ1ZmZlcjEsIC8vIElwCgkJCUJ1ZmZlcjIsIC8vIFRvdGFsCgkJCUJ1ZmZlcjMsIC8vIFRvdGFsU2VudAoJCQlCdWZmZXI0LCAvLyBUb3RhbFJlY2VpdmVkCgkJCUJ1ZmZlcjRiLCAvLyBGVFAKCQkJQnVmZmVyNSwgLy8gSFRUUAoJCQlCdWZmZXI1YiwgLy8gUDJQCgkJCUJ1ZmZlcjYsIC8vIFRDUAoJCQlCdWZmZXI3LCAvLyBVRFAKCQkJQnVmZmVyOCk7IC8vIElDTVAKCWVsc2UKCQlmcHJpbnRmKHN0cmVhbSwgIjxURD4lczwvVEQ+JXMlcyVzJXMlcyVzJXMlcyVzPC9UUj5cbiIsCgkJCUJ1ZmZlcjEsIC8vIElwCgkJCUJ1ZmZlcjIsIC8vIFRvdGFsCgkJCUJ1ZmZlcjMsIC8vIFRvdGFsU2VudAoJCQlCdWZmZXI0LCAvLyBUb3RhbFJlY2VpdmVkCgkJCUJ1ZmZlcjRiLCAvLyBGVFAKCQkJQnVmZmVyNSwgLy8gSFRUUAoJCQlCdWZmZXI1YiwgLy8gUDJQCQkKCQkJQnVmZmVyNiwgLy8gVENQCgkJCUJ1ZmZlcjcsIC8vIFVEUAoJCQlCdWZmZXI4KTsgLy8gSUNNUAoJfQoKdm9pZCBNYWtlSW5kZXhQYWdlcyhpbnQgTnVtSXBzLCBzdHJ1Y3QgU3VtbWFyeURhdGEgKlN1bW1hcnlEYXRhW10pCgl7CglpbnQgU3VibmV0Q291bnRlcjsKCWludCBDb3VudGVyLCB0Q291bnRlcjsKCXRpbWVfdCBXcml0ZVRpbWU7CgljaGFyIGZpbGVuYW1lW10gPSAiLi9odGRvY3MvaW5kZXgyLmh0bWwiOwoJY2hhciAqUGVyaW9kRGVzYzsKCQoJRklMRSAqZmlsZTsKCgljaGFyIEJ1ZmZlcjFbNTBdOwoJY2hhciBCdWZmZXIyWzUwXTsKCWNoYXIgSG9zdE5hbWVbMjU1XTsKCglXcml0ZVRpbWUgPSB0aW1lKE5VTEwpOwoJCglRdWlja1NvcnRTdW1tYXJ5RGF0YShTdW1tYXJ5RGF0YSwgMCwgTnVtSXBzLTEpOwoKCS8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLwoJLy8gUHJpbnQgbWFpbiBpbmRleCBwYWdlCgkKCWlmIChjb25maWcudGFnID09ICcxJykKCQl7CgkJaWYgKChmaWxlID0gZm9wZW4oIi4vaHRkb2NzL2luZGV4Lmh0bWwiLCAid3QiKSkgPT0gTlVMTCkKCQkJewoJCQlzeXNsb2coTE9HX0VSUiwgIkZhaWxlZCB0byBvcGVuIC4vaHRkb2NzL2luZGV4Lmh0bWwiKTsKCQkJZXhpdCgxKTsKCQkJfQoJCX0KCWVsc2UKCQl7CgkJZmlsZW5hbWVbMTRdID0gY29uZmlnLnRhZzsKCQlpZiAoKGZpbGUgPSBmb3BlbihmaWxlbmFtZSwgInd0IikpID09IE5VTEwpCgkJCXsKCQkJc3lzbG9nKExPR19FUlIsICJGYWlsZWQgdG8gb3BlbiAlcyIsIGZpbGVuYW1lKTsKCQkJZXhpdCgxKTsKCQkJfQoJCX0KCglzd2l0Y2ggKGNvbmZpZy50YWcpCgkJewoJCWNhc2UgJzEnOiBQZXJpb2REZXNjID0gIkRhaWx5IjsgYnJlYWs7CgkJY2FzZSAnMic6IFBlcmlvZERlc2MgPSAiV2Vla2x5IjsgYnJlYWs7CgkJY2FzZSAnMyc6IFBlcmlvZERlc2MgPSAiTW9udGhseSI7IGJyZWFrOwoJCWNhc2UgJzQnOiBQZXJpb2REZXNjID0gIlllYXJseSI7IGJyZWFrOwoJCWRlZmF1bHQ6IFBlcmlvZERlc2MgPSAiIjsgYnJlYWs7CgkJfQoJCglmcHJpbnRmKGZpbGUsICI8IURPQ1RZUEUgSFRNTCBQVUJMSUMgXCItLy9XM0MvL0RURCBIVE1MIDQuMDEgVHJhbnNpdGlvbmFsLy9FTlwiPlxuIik7CglmcHJpbnRmKGZpbGUsICI8SFRNTD5cbjxIRUFEPlxuPFRJVExFPkJhbmR3aWR0aGQ8L1RJVExFPlxuIik7CgoJaWYgKGNvbmZpZy5tZXRhX3JlZnJlc2gpCgkJZnByaW50ZihmaWxlLCAiPE1FVEEgSFRUUC1FUVVJVj1cIlJFRlJFU0hcIiBjb250ZW50PVwiJXVcIj5cbiIsCgkJCQljb25maWcubWV0YV9yZWZyZXNoKTsKCWZwcmludGYoZmlsZSwgIjxNRVRBIEhUVFAtRVFVSVY9XCJFWFBJUkVTXCIgY29udGVudD1cIi0xXCI+XG4iKTsKCWZwcmludGYoZmlsZSwgIjxNRVRBIEhUVFAtRVFVSVY9XCJQUkFHTUFcIiBjb250ZW50PVwibm8tY2FjaGVcIj5cbiIpOwoJZnByaW50ZihmaWxlLCAiPC9IRUFEPlxuPEJPRFkgdmxpbms9Ymx1ZT5cbiVzPGJyPlxuPGNlbnRlcj48aW1nIHNyYz1cImxvZ28uZ2lmXCIgQUxUPVwiTG9nb1wiPjxCUj5cbiIsIGN0aW1lKCZXcml0ZVRpbWUpKTsKCWZwcmludGYoZmlsZSwgIlByb2dyYW1tZWQgYnkgRGF2aWQgSGlua2xlLCBDb21taXNzaW9uZWQgYnkgPGEgaHJlZj1cImh0dHA6Ly93d3cuZGVyYnl0ZWNoLmNvbVwiPkRlcmJ5VGVjaDwvYT4gd2lyZWxlc3MgbmV0d29ya2luZy48QlI+Iik7CglmcHJpbnRmKGZpbGUsICI8QlI+XG4gLSA8YSBocmVmPVwiaW5kZXguaHRtbFwiPkRhaWx5PC9hPiAtLSA8YSBocmVmPVwiaW5kZXgyLmh0bWxcIj5XZWVrbHk8L2E+IC0tICIpOwoJZnByaW50ZihmaWxlLCAiPGEgaHJlZj1cImluZGV4My5odG1sXCI+TW9udGhseTwvYT4gLS0gPGEgaHJlZj1cImluZGV4NC5odG1sXCI+WWVhcmx5PC9hPiAtIDxCUj5cbiIpOwoKCWZwcmludGYoZmlsZSwgIjxCUj5cblBpY2sgYSBTdWJuZXQ6PEJSPlxuIik7CQoJaWYgKGNvbmZpZy50YWcgPT0gJzEnKQoJCWZwcmludGYoZmlsZSwgIi0gPGEgaHJlZj1cImluZGV4Lmh0bWxcIj5Ub3AyMDwvYT4gLSIpOwoJZWxzZQoJCWZwcmludGYoZmlsZSwgIi0gPGEgaHJlZj1cImluZGV4JWMuaHRtbFwiPlRvcDIwPC9hPiAtIiwgY29uZmlnLnRhZyk7CgoJZm9yIChDb3VudGVyID0gMDsgQ291bnRlciA8IFN1Ym5ldENvdW50OyBDb3VudGVyKyspICAgICAgICAgICAgCgkJewoJCUhvc3RJcDJDaGFySXAoU3VibmV0VGFibGVbQ291bnRlcl0uaXAsIEJ1ZmZlcjEpOwoJCWZwcmludGYoZmlsZSwgIi0gPGEgaHJlZj1cIlN1Ym5ldC0lYy0lcy5odG1sXCI+JXM8L2E+IC0iLCBjb25maWcudGFnLCBCdWZmZXIxLCBCdWZmZXIxKTsKCQl9CgoJLy8vLy8gIFRPUCAyMAoKCWZwcmludGYoZmlsZSwgIjxIMT5Ub3AgMjAgSVBzIGJ5IFRyYWZmaWMgLSAlczwvSDE+PC9jZW50ZXI+IiwgUGVyaW9kRGVzYyk7CglmcHJpbnRmKGZpbGUsICI8Y2VudGVyPlxuPHRhYmxlIHdpZHRoPVwiMTAwJSVcIiBib3JkZXI9MSBjZWxsc3BhY2luZz0wPlxuIik7CgogICAgLy8gUEFTUyAxOiAgV3JpdGUgb3V0IHRoZSB0YWJsZQoKCWZwcmludGYoZmlsZSwgIjxUUiBiZ2NvbG9yPWxpZ2h0Ymx1ZT48VEQ+SXAgYW5kIE5hbWU8VEQgYWxpZ249Y2VudGVyPlRvdGFsPFREIGFsaWduPWNlbnRlcj5Ub3RhbCBTZW50PFREIGFsaWduPWNlbnRlcj5Ub3RhbCBSZWNlaXZlZDxURCBhbGlnbj1jZW50ZXI+RlRQPFREIGFsaWduPWNlbnRlcj5IVFRQPFREIGFsaWduPWNlbnRlcj5QMlA8VEQgYWxpZ249Y2VudGVyPlRDUDxURCBhbGlnbj1jZW50ZXI+VURQPFREIGFsaWduPWNlbnRlcj5JQ01QXG4iKTsKCWZvciAoQ291bnRlcj0wOyBDb3VudGVyIDwgMjEgJiYgQ291bnRlciA8IE51bUlwczsgQ291bnRlcisrKQoJCVByaW50VGFibGVMaW5lKGZpbGUsIFN1bW1hcnlEYXRhW0NvdW50ZXJdLCBDb3VudGVyKTsKCglmcHJpbnRmKGZpbGUsICI8L3RhYmxlPjwvY2VudGVyPlxuIik7CgoJLy8gUEFTUyAyOiBUaGUgZ3JhcGhzCglmb3IgKENvdW50ZXI9MDsgQ291bnRlciA8IDIxICYmIENvdW50ZXIgPCBOdW1JcHM7IENvdW50ZXIrKykKCQlpZiAoU3VtbWFyeURhdGFbQ291bnRlcl0tPkdyYXBoKQoJCQl7CgkJCWlmIChTdW1tYXJ5RGF0YVtDb3VudGVyXS0+SVAgPT0gMCkKCQkJCXsKCQkJCXN0cmNweShCdWZmZXIxLCAiVG90YWwiKTsJCgkJCQlzdHJjcHkoSG9zdE5hbWUsICJUb3RhbCBvZiBhbGwgc3VibmV0cyIpOwoJCQkJfQoJCQllbHNlCgkJCQl7CQoJCQkJSG9zdElwMkNoYXJJcChTdW1tYXJ5RGF0YVtDb3VudGVyXS0+SVAsIEJ1ZmZlcjEpOwoJCQkJcmRucyhIb3N0TmFtZSwgU3VtbWFyeURhdGFbQ291bnRlcl0tPklQKTsKCQkJCX0KCQkJZnByaW50ZihmaWxlLCAiPGEgbmFtZT1cIiVzLSVjXCI+PC9hPjxIMT48YSBocmVmPVwiI3RvcFwiPihUb3ApPC9hPiAlcyAtICVzPC9IMT48QlI+XG5TZW5kOjxicj5cbjxpbWcgc3JjPSVzLSVjLVMucG5nIEFMVD1cIlNlbnQgdHJhZmZpYyBmb3IgJXNcIj48QlI+XG48aW1nIHNyYz1sZWdlbmQuZ2lmIEFMVD1cIkxlZ2VuZFwiPjxicj5cblJlY2VpdmVkOjxicj5cbjxpbWcgc3JjPSVzLSVjLVIucG5nIEFMVD1cIlNlbnQgdHJhZmZpYyBmb3IgJXNcIj48QlI+XG48aW1nIHNyYz1sZWdlbmQuZ2lmIEFMVD1cIkxlZ2VuZFwiPjxicj5cbjxCUj5cbiIsIEJ1ZmZlcjEsIGNvbmZpZy50YWcsIEJ1ZmZlcjEsIEhvc3ROYW1lLCBCdWZmZXIxLCBjb25maWcudGFnLCBCdWZmZXIxLCBCdWZmZXIxLCBjb25maWcudGFnLCBCdWZmZXIxKTsKCQkJfQoKCWZwcmludGYoZmlsZSwgIjwvQk9EWT48L0hUTUw+XG4iKTsKCglmY2xvc2UoZmlsZSk7CgoJLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vCgkvLyBQcmludCBlYWNoIHN1Ym5ldCBwYWdlCgoJZm9yIChTdWJuZXRDb3VudGVyID0gMDsgU3VibmV0Q291bnRlciA8IFN1Ym5ldENvdW50OyBTdWJuZXRDb3VudGVyKyspCgkJewoJCUhvc3RJcDJDaGFySXAoU3VibmV0VGFibGVbU3VibmV0Q291bnRlcl0uaXAsIEJ1ZmZlcjEpOwoJCXNwcmludGYoQnVmZmVyMiwgIi4vaHRkb2NzL1N1Ym5ldC0lYy0lcy5odG1sIiwgY29uZmlnLnRhZywgQnVmZmVyMSk7CgkJZmlsZSA9IGZvcGVuKEJ1ZmZlcjIsICJ3dCIpOwoJCWZwcmludGYoZmlsZSwgIjwhRE9DVFlQRSBIVE1MIFBVQkxJQyBcIi0vL1czQy8vRFREIEhUTUwgNC4wMSBUcmFuc2l0aW9uYWwvL0VOXCI+XG4iKTsKCQlmcHJpbnRmKGZpbGUsICI8SFRNTD5cbjxIRUFEPjxUSVRMRT5CYW5kd2lkdGhkIC0gU3VibmV0ICVzPC9USVRMRT5cbiIsIEJ1ZmZlcjEpOwoKCQlpZiAoY29uZmlnLm1ldGFfcmVmcmVzaCkKCQkJZnByaW50ZihmaWxlLCAiPE1FVEEgSFRUUC1FUVVJVj1cIlJFRlJFU0hcIiBjb250ZW50PVwiJXVcIj5cbiIsCgkJCQkJY29uZmlnLm1ldGFfcmVmcmVzaCk7CgkJZnByaW50ZihmaWxlLCAiPE1FVEEgSFRUUC1FUVVJVj1cIkVYUElSRVNcIiBjb250ZW50PVwiLTFcIj5cbiIpOwoJCWZwcmludGYoZmlsZSwgIjxNRVRBIEhUVFAtRVFVSVY9XCJQUkFHTUFcIiBjb250ZW50PVwibm8tY2FjaGVcIj5cbiIpOwoJCWZwcmludGYoZmlsZSwgIjwvSEVBRD5cbjxCT0RZIHZsaW5rPWJsdWU+XG4lczxicj5cbjxDRU5URVI+PGEgbmFtZT1cIlRvcFwiPjwvYT4iLCBjdGltZSgmV3JpdGVUaW1lKSk7CgkJZnByaW50ZihmaWxlLCAiPGltZyBzcmM9XCJsb2dvLmdpZlwiIEFMVD1cIkxvZ29cIj48QlI+Iik7CgkJZnByaW50ZihmaWxlLCAiUHJvZ3JhbW1lZCBieSBEYXZpZCBIaW5rbGUsIENvbW1pc3Npb25lZCBieSA8YSBocmVmPVwiaHR0cDovL3d3dy5kZXJieXRlY2guY29tXCI+RGVyYnlUZWNoPC9hPiB3aXJlbGVzcyBuZXR3b3JraW5nLjxCUj5cbiIpOwoKCQlmcHJpbnRmKGZpbGUsICI8QlI+XG4gLSA8YSBocmVmPVwiaW5kZXguaHRtbFwiPkRhaWx5PC9hPiAtLSA8YSBocmVmPVwiaW5kZXgyLmh0bWxcIj5XZWVrbHk8L2E+IC0tICIpOwoJCWZwcmludGYoZmlsZSwgIjxhIGhyZWY9XCJpbmRleDMuaHRtbFwiPk1vbnRobHk8L2E+IC0tIDxhIGhyZWY9XCJpbmRleDQuaHRtbFwiPlllYXJseTwvYT4gLSA8QlI+XG4iKTsKCgkJZnByaW50ZihmaWxlLCAiPEJSPlxuUGljayBhIFN1Ym5ldDo8QlI+XG4iKTsKCQlpZiAoY29uZmlnLnRhZyA9PSAnMScpCgkJCWZwcmludGYoZmlsZSwgIi0gPGEgaHJlZj1cImluZGV4Lmh0bWxcIj5Ub3AyMDwvYT4gLSIpOwoJCWVsc2UKCQkJZnByaW50ZihmaWxlLCAiLSA8YSBocmVmPVwiaW5kZXglYy5odG1sXCI+VG9wMjA8L2E+IC0iLCBjb25maWcudGFnKTsKCgkJZm9yIChDb3VudGVyID0gMDsgQ291bnRlciA8IFN1Ym5ldENvdW50OyBDb3VudGVyKyspCgkJCXsKCQkJSG9zdElwMkNoYXJJcChTdWJuZXRUYWJsZVtDb3VudGVyXS5pcCwgQnVmZmVyMik7CgkJCWZwcmludGYoZmlsZSwgIi0gPGEgaHJlZj1cIlN1Ym5ldC0lYy0lcy5odG1sXCI+JXM8L2E+IC0iLCBjb25maWcudGFnLCBCdWZmZXIyLCBCdWZmZXIyKTsKCQkJfQoKCQlmcHJpbnRmKGZpbGUsICI8SDE+JXMgLSAlczwvSDE+PC9jZW50ZXI+IiwgQnVmZmVyMSwgUGVyaW9kRGVzYyk7CgkJZnByaW50ZihmaWxlLCAiPHRhYmxlIHdpZHRoPVwiMTAwJSVcIiBib3JkZXI9MSBjZWxsc3BhY2luZz0wPlxuIik7CgogICAgICAgIC8vIFBBU1MgMTogIFdyaXRlIG91dCB0aGUgdGFibGUKCgkJZnByaW50ZihmaWxlLCAiPFRSIGJnY29sb3I9bGlnaHRibHVlPjxURD5JcCBhbmQgTmFtZTxURCBhbGlnbj1jZW50ZXI+VG90YWw8VEQgYWxpZ249Y2VudGVyPlRvdGFsIFNlbnQ8VEQgYWxpZ249Y2VudGVyPlRvdGFsIFJlY2VpdmVkPFREIGFsaWduPWNlbnRlcj5GVFA8VEQgYWxpZ249Y2VudGVyPkhUVFA8VEQgYWxpZ249Y2VudGVyPlAyUDxURCBhbGlnbj1jZW50ZXI+VENQPFREIGFsaWduPWNlbnRlcj5VRFA8VEQgYWxpZ249Y2VudGVyPklDTVBcbiIpOwoJCWZvciAodENvdW50ZXI9MCwgQ291bnRlcj0wOyBDb3VudGVyIDwgTnVtSXBzOyBDb3VudGVyKyspCgkJCXsKICAgICAgICAgICAgaWYgKFN1Ym5ldFRhYmxlW1N1Ym5ldENvdW50ZXJdLmlwID09IChTdW1tYXJ5RGF0YVtDb3VudGVyXS0+SVAgJiBTdWJuZXRUYWJsZVtTdWJuZXRDb3VudGVyXS5tYXNrKSkKCQkJCXsgLy8gVGhlIGlwIGJlbG9uZ3MgdG8gdGhpcyBzdWJuZXQKCQkJCVByaW50VGFibGVMaW5lKGZpbGUsIFN1bW1hcnlEYXRhW0NvdW50ZXJdLCB0Q291bnRlcisrKTsKICAgIAkJCX0KCQkJfQoKCQlmcHJpbnRmKGZpbGUsICI8L3RhYmxlPlxuIik7CgoJCS8vIFBBU1MgMjogVGhlIGdyYXBocwoJCWZvciAoQ291bnRlcj0wOyBDb3VudGVyIDwgTnVtSXBzOyBDb3VudGVyKyspCgkJCXsKICAgICAgICAgICAgaWYgKFN1Ym5ldFRhYmxlW1N1Ym5ldENvdW50ZXJdLmlwID09IChTdW1tYXJ5RGF0YVtDb3VudGVyXS0+SVAgJiBTdWJuZXRUYWJsZVtTdWJuZXRDb3VudGVyXS5tYXNrKSkKCQkJCXsgLy8gVGhlIGlwIGJlbG9uZ3MgdG8gdGhpcyBzdWJuZXQKCQkJCWlmIChTdW1tYXJ5RGF0YVtDb3VudGVyXS0+R3JhcGgpCgkJCQkJewoJCQkJCUhvc3RJcDJDaGFySXAoU3VtbWFyeURhdGFbQ291bnRlcl0tPklQLCBCdWZmZXIxKTsKCQkJCQlyZG5zKEhvc3ROYW1lLCBTdW1tYXJ5RGF0YVtDb3VudGVyXS0+SVApOwoJCQkJCWZwcmludGYoZmlsZSwgIjxhIG5hbWU9XCIlcy0lY1wiPjwvYT48SDE+PGEgaHJlZj1cIiN0b3BcIj4oVG9wKTwvYT4gJXMgLSAlczwvSDE+PEJSPlxuU2VuZDo8YnI+XG48aW1nIHNyYz0lcy0lYy1TLnBuZyBBTFQ9XCJTZW50IHRyYWZmaWMgZ3JhcGggZm9yICVzXCI+PEJSPlxuPGltZyBzcmM9bGVnZW5kLmdpZiBBTFQ9XCJMZWdlbmRcIj48YnI+XG5SZWNlaXZlZDo8YnI+XG48aW1nIHNyYz0lcy0lYy1SLnBuZyBBTFQ9XCJSZWNlaXZlZCB0cmFmZmljIGZvciAlc1wiPjxCUj5cbjxpbWcgc3JjPWxlZ2VuZC5naWYgQUxUPVwiTGVnZW5kXCI+PGJyPlxuPEJSPlxuIiwgQnVmZmVyMSwgY29uZmlnLnRhZywgQnVmZmVyMSwgSG9zdE5hbWUsIEJ1ZmZlcjEsIGNvbmZpZy50YWcsIEJ1ZmZlcjEsIEJ1ZmZlcjEsIGNvbmZpZy50YWcsIEJ1ZmZlcjEpOwoJCQkJCX0KCQkJCX0KCQkJfQoKCQlmcHJpbnRmKGZpbGUsICI8L0JPRFk+PC9IVE1MPlxuIik7CgkJZmNsb3NlKGZpbGUpOwoJCX0KCglmcmVlKFN1bW1hcnlEYXRhKTsKCX0KCnZvaWQgR3JhcGhJcChzdHJ1Y3QgSVBEYXRhU3RvcmUgKkRhdGFTdG9yZSwgc3RydWN0IFN1bW1hcnlEYXRhICpTdW1tYXJ5RGF0YSwgdGltZV90IHRpbWVzdGFtcCkKICAgIHsKICAgIEZJTEUgKk91dHB1dEZpbGU7CiAgICBjaGFyIG91dHB1dGZpbGVuYW1lWzUwXTsKICAgIGdkSW1hZ2VQdHIgaW0sIGltMjsKICAgIGludCB3aGl0ZTsKICAgIHVuc2lnbmVkIGxvbmcgbG9uZyBpbnQgWU1heDsKCWNoYXIgQ2hhcklwWzIwXTsKCiAgICB0aW1lX3QgR3JhcGhCZWdpblRpbWU7CgoJLy8gVE9ETzogRmlyc3QgZGV0ZXJtaW5lIGlmIGdyYXBoIHdpbGwgYmUgcHJpbnRlZCBiZWZvcmUgY3JlYXRpbmcgaW1hZ2UgYW5kIGRyYXdpbmcgYmFja3JvdW5kLCBldGMKCglpZiAoRGF0YVN0b3JlLT5pcCA9PSAwKQoJCXN0cmNweShDaGFySXAsICJUb3RhbCIpOwoJZWxzZQoJCUhvc3RJcDJDaGFySXAoRGF0YVN0b3JlLT5pcCwgQ2hhcklwKTsKCiAgICBHcmFwaEJlZ2luVGltZSA9IHRpbWVzdGFtcCAtIGNvbmZpZy5yYW5nZTsKCiAgICBpbSA9IGdkSW1hZ2VDcmVhdGUoWFdJRFRILCBZSEVJR0hUKTsKICAgIHdoaXRlID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDI1NSwgMjU1LCAyNTUpOwogICAgLy9nZEltYWdlRmlsbChpbSwgMTAsIDEwLCB3aGl0ZSk7CgogICAgaW0yID0gZ2RJbWFnZUNyZWF0ZShYV0lEVEgsIFlIRUlHSFQpOwogICAgd2hpdGUgPSBnZEltYWdlQ29sb3JBbGxvY2F0ZShpbTIsIDI1NSwgMjU1LCAyNTUpOwogICAgLy9nZEltYWdlRmlsbChpbTIsIDEwLCAxMCwgd2hpdGUpOwoKICAgIFlNYXggPSBHcmFwaERhdGEoaW0sIGltMiwgRGF0YVN0b3JlLCBHcmFwaEJlZ2luVGltZSwgU3VtbWFyeURhdGEpOwogICAgaWYgKFlNYXggIT0gMCkKICAgICAgICB7CiAgICAgICAgLy8gRmluaXNoIHRoZSBncmFwaAogICAgICAgIFByZXBhcmVYQXhpcyhpbSwgdGltZXN0YW1wKTsKICAgICAgICBQcmVwYXJlWUF4aXMoaW0sIFlNYXgpOwoKICAgICAgICBQcmVwYXJlWEF4aXMoaW0yLCB0aW1lc3RhbXApOwogICAgICAgIFByZXBhcmVZQXhpcyhpbTIsIFlNYXgpOwoKICAgICAgICBzcHJpbnRmKG91dHB1dGZpbGVuYW1lLCAiLi9odGRvY3MvJXMtJWMtUy5wbmciLCBDaGFySXAsIGNvbmZpZy50YWcpOwogICAgICAgIE91dHB1dEZpbGUgPSBmb3BlbihvdXRwdXRmaWxlbmFtZSwgIndiIik7ICAgIAogICAgICAgIGdkSW1hZ2VQbmcoaW0sIE91dHB1dEZpbGUpOwogICAgICAgIGZjbG9zZShPdXRwdXRGaWxlKTsKCiAgICAgICAgc3ByaW50ZihvdXRwdXRmaWxlbmFtZSwgIi4vaHRkb2NzLyVzLSVjLVIucG5nIiwgQ2hhcklwLCBjb25maWcudGFnKTsKICAgICAgICBPdXRwdXRGaWxlID0gZm9wZW4ob3V0cHV0ZmlsZW5hbWUsICJ3YiIpOwogICAgICAgIGdkSW1hZ2VQbmcoaW0yLCBPdXRwdXRGaWxlKTsKICAgICAgICBmY2xvc2UoT3V0cHV0RmlsZSk7CiAgICAgICAgfQogICAgZWxzZQogICAgICAgIHsKICAgICAgICAvLyBUaGUgZ3JhcGggaXNuJ3Qgd29ydGggY2x1dGVyaW5nIHVwIHRoZSB3ZWIgcGFnZXMgd2l0aAogICAgICAgIHNwcmludGYob3V0cHV0ZmlsZW5hbWUsICIuL2h0ZG9jcy8lcy0lYy1SLnBuZyIsIENoYXJJcCwgY29uZmlnLnRhZyk7CiAgICAgICAgdW5saW5rKG91dHB1dGZpbGVuYW1lKTsKICAgICAgICBzcHJpbnRmKG91dHB1dGZpbGVuYW1lLCAiLi9odGRvY3MvJXMtJWMtUy5wbmciLCBDaGFySXAsIGNvbmZpZy50YWcpOwogICAgICAgIHVubGluayhvdXRwdXRmaWxlbmFtZSk7CiAgICAgICAgfQoKCWdkSW1hZ2VEZXN0cm95KGltKTsKCWdkSW1hZ2VEZXN0cm95KGltMik7CiAgICB9CgovLyBSZXR1cm5zIFlNYXgKdW5zaWduZWQgbG9uZyBsb25nIGludCBHcmFwaERhdGEoZ2RJbWFnZVB0ciBpbSwgZ2RJbWFnZVB0ciBpbTIsIHN0cnVjdCBJUERhdGFTdG9yZSAqRGF0YVN0b3JlLCB0aW1lX3QgdGltZXN0YW1wLCBzdHJ1Y3QgU3VtbWFyeURhdGEgKlN1bW1hcnlEYXRhKQogICAgewogICAgdW5zaWduZWQgbG9uZyBsb25nIGludCBZTWF4PTA7CgkKCXN0cnVjdCBEYXRhU3RvcmVCbG9jayAqQ3VycmVudEJsb2NrOwogICAgc3RydWN0IElQRGF0YSAqRGF0YTsKCgkvLyBUT0RPOiBUaGVzZSBzaG91bGQgYmUgYSBzdHJ1Y3R1cmUhISEhCgkvLyBUT0RPOiBUaGlzIGlzIGFuIGF3ZnVsbCBsb3Qgb2YgZGF0YSB0byBiZSBhbGxvY2F0ZWQgb24gdGhlIHN0YWNrCgogICAgdW5zaWduZWQgbG9uZyBsb25nIHRvdGFsW1hXSURUSF07CiAgICB1bnNpZ25lZCBsb25nIGxvbmcgaWNtcFtYV0lEVEhdOwogICAgdW5zaWduZWQgbG9uZyBsb25nIHVkcFtYV0lEVEhdOwogICAgdW5zaWduZWQgbG9uZyBsb25nIHRjcFtYV0lEVEhdOwoJdW5zaWduZWQgbG9uZyBsb25nIGZ0cFtYV0lEVEhdOwogICAgdW5zaWduZWQgbG9uZyBsb25nIGh0dHBbWFdJRFRIXTsKICAgIHVuc2lnbmVkIGxvbmcgbG9uZyBwMnBbWFdJRFRIXTsKICAgIGludCBDb3VudFtYV0lEVEhdOwoKICAgIHVuc2lnbmVkIGxvbmcgbG9uZyB0b3RhbDJbWFdJRFRIXTsKICAgIHVuc2lnbmVkIGxvbmcgbG9uZyBpY21wMltYV0lEVEhdOwogICAgdW5zaWduZWQgbG9uZyBsb25nIHVkcDJbWFdJRFRIXTsKICAgIHVuc2lnbmVkIGxvbmcgbG9uZyB0Y3AyW1hXSURUSF07Cgl1bnNpZ25lZCBsb25nIGxvbmcgZnRwMltYV0lEVEhdOwogICAgdW5zaWduZWQgbG9uZyBsb25nIGh0dHAyW1hXSURUSF07CiAgICB1bnNpZ25lZCBsb25nIGxvbmcgcDJwMltYV0lEVEhdOwoKICAgIHNpemVfdCBEYXRhUG9pbnRzOwogICAgZG91YmxlIHg7CiAgICBpbnQgeGludDsKICAgIGludCBDb3VudGVyOwogICAgY2hhciBCdWZmZXJbMzBdOwogICAgY2hhciBCdWZmZXIyWzUwXTsKICAgIAogICAgaW50IGJsdWUsIGxibHVlLCByZWQsIHB1cnBsZSwgZ3JlZW4sIGJyb3duLCBibGFjazsKICAgIGludCBibHVlMiwgbGJsdWUyLCByZWQyLCBwdXJwbGUyLCBncmVlbjIsIGJyb3duMiwgYmxhY2syOwoKCXVuc2lnbmVkIGxvbmcgbG9uZyBpbnQgU2VudFBlYWsgPSAwOwoJdW5zaWduZWQgbG9uZyBsb25nIGludCBSZWNlaXZlZFBlYWsgPSAwOwoKICAgIHB1cnBsZSAgID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDI1NSwgMCwgMjU1KTsKICAgIGdyZWVuICAgID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDAsIDI1NSwgMCk7CiAgICBibHVlICAgICA9IGdkSW1hZ2VDb2xvckFsbG9jYXRlKGltLCAwLCAwLCAyNTUpOwoJbGJsdWUJID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDEyOCwgMTI4LCAyNTUpOwogICAgYnJvd24gICAgPSBnZEltYWdlQ29sb3JBbGxvY2F0ZShpbSwgMTI4LCAwLCAwKTsKICAgIHJlZCAgICAgID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDI1NSwgMCwgMCk7CiAgICBibGFjayAJID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDAsIDAsIDApOwogICAgCiAgICBwdXJwbGUyICAgPSBnZEltYWdlQ29sb3JBbGxvY2F0ZShpbTIsIDI1NSwgMCwgMjU1KTsKICAgIGdyZWVuMiAgID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0yLCAwLCAyNTUsIDApOwogICAgYmx1ZTIgICAgPSBnZEltYWdlQ29sb3JBbGxvY2F0ZShpbTIsIDAsIDAsIDI1NSk7CglsYmx1ZTIJID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0yLCAxMjgsIDEyOCwgMjU1KTsKICAgIGJyb3duMiAgID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0yLCAxMjgsIDAsIDApOwogICAgcmVkMiAgICAgPSBnZEltYWdlQ29sb3JBbGxvY2F0ZShpbTIsIDI1NSwgMCwgMCk7CiAgICBibGFjazIgICA9IGdkSW1hZ2VDb2xvckFsbG9jYXRlKGltMiwgMCwgMCwgMCk7CgoJQ3VycmVudEJsb2NrID0gRGF0YVN0b3JlLT5GaXJzdEJsb2NrOwoJRGF0YSA9IEN1cnJlbnRCbG9jay0+RGF0YTsKICAgIERhdGFQb2ludHMgPSBDdXJyZW50QmxvY2stPk51bUVudHJpZXM7CgoJbWVtc2V0KFN1bW1hcnlEYXRhLCAwLCBzaXplb2Yoc3RydWN0IFN1bW1hcnlEYXRhKSk7CglTdW1tYXJ5RGF0YS0+SVAgPSBEYXRhWzBdLmlwOwoJCiAgICBtZW1zZXQoQ291bnQsIDAsIHNpemVvZihDb3VudFswXSkqWFdJRFRIKTsKCiAgICBtZW1zZXQodG90YWwsIDAsIHNpemVvZih0b3RhbFswXSkqWFdJRFRIKTsKICAgIG1lbXNldChpY21wLCAwLCBzaXplb2YodG90YWxbMF0pKlhXSURUSCk7CiAgICBtZW1zZXQodWRwLCAwLCBzaXplb2YodG90YWxbMF0pKlhXSURUSCk7CiAgICBtZW1zZXQodGNwLCAwLCBzaXplb2YodG90YWxbMF0pKlhXSURUSCk7CgltZW1zZXQoZnRwLCAwLCBzaXplb2YodG90YWxbMF0pKlhXSURUSCk7CiAgICBtZW1zZXQoaHR0cCwgMCwgc2l6ZW9mKHRvdGFsWzBdKSpYV0lEVEgpOwogICAgbWVtc2V0KHAycCwgMCwgc2l6ZW9mKHRvdGFsWzBdKSpYV0lEVEgpOwoKICAgIG1lbXNldCh0b3RhbDIsIDAsIHNpemVvZih0b3RhbFswXSkqWFdJRFRIKTsKICAgIG1lbXNldChpY21wMiwgMCwgc2l6ZW9mKHRvdGFsWzBdKSpYV0lEVEgpOwogICAgbWVtc2V0KHVkcDIsIDAsIHNpemVvZih0b3RhbFswXSkqWFdJRFRIKTsKICAgIG1lbXNldCh0Y3AyLCAwLCBzaXplb2YodG90YWxbMF0pKlhXSURUSCk7CiAgICBtZW1zZXQoZnRwMiwgMCwgc2l6ZW9mKHRvdGFsWzBdKSpYV0lEVEgpOwogICAgbWVtc2V0KGh0dHAyLCAwLCBzaXplb2YodG90YWxbMF0pKlhXSURUSCk7CiAgICBtZW1zZXQocDJwMiwgMCwgc2l6ZW9mKHRvdGFsWzBdKSpYV0lEVEgpOwoKCS8vIENoYW5nZSB0aGlzIHRvIGp1c3QgcnVuIHRocm91Z2ggYWxsIHRoZSBkYXRhcG9pbnRzIHdlIGhhdmUgc3RvcmVkIGluIHJhbQoKCS8vIFN1bSB1cCB0aGUgYnl0ZXMvc2Vjb25kCiAgICB3aGlsZShEYXRhUG9pbnRzID4gMCkgIC8vIFdlIGhhdmUgZGF0YSB0byBncmFwaAogICAgICAgIHsKICAgICAgICBmb3IgKENvdW50ZXIgPSAwOyBDb3VudGVyIDwgRGF0YVBvaW50czsgQ291bnRlcisrKSAgLy8gR3JhcGggaXQgYWxsCiAgICAgICAgICAgIHsKICAgICAgICAgICAgeCA9IChEYXRhW0NvdW50ZXJdLnRpbWVzdGFtcC10aW1lc3RhbXApKigoWFdJRFRILVhPRkZTRVQpL2NvbmZpZy5yYW5nZSkrWE9GRlNFVDsgICAgICAgIAogICAgICAgICAgICB4aW50ID0geDsKCiAgICAgICAgICAgIGlmICh4aW50ID49IDAgJiYgeGludCA8IFhXSURUSCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIENvdW50W3hpbnRdKys7CgkJCQkKCQkJCWlmIChEYXRhW0NvdW50ZXJdLlNlbmQudG90YWwgPiBTZW50UGVhaykKCQkJCQlTZW50UGVhayA9IERhdGFbQ291bnRlcl0uU2VuZC50b3RhbDsKICAgICAgIAkgICAgICAgIHRvdGFsW3hpbnRdICs9IERhdGFbQ291bnRlcl0uU2VuZC50b3RhbDsKICAgICAgICAgICAJICAgIGljbXBbeGludF0gKz0gRGF0YVtDb3VudGVyXS5TZW5kLmljbXA7CiAgICAgICAgICAgICAgIAl1ZHBbeGludF0gKz0gRGF0YVtDb3VudGVyXS5TZW5kLnVkcDsKICAgICAgICAgICAgICAgIHRjcFt4aW50XSArPSBEYXRhW0NvdW50ZXJdLlNlbmQudGNwOwoJCQkJZnRwW3hpbnRdICs9IERhdGFbQ291bnRlcl0uU2VuZC5mdHA7CiAgICAgICAJICAgICAgICBodHRwW3hpbnRdICs9IERhdGFbQ291bnRlcl0uU2VuZC5odHRwOwoJCQkJcDJwW3hpbnRdICs9IERhdGFbQ291bnRlcl0uU2VuZC5wMnA7CgogICAgICAgICAgICAgICAgaWYgKERhdGFbQ291bnRlcl0uUmVjZWl2ZS50b3RhbCA+IFJlY2VpdmVkUGVhaykKICAgCSAgICAgICAgICAgIAlSZWNlaXZlZFBlYWsgPSBEYXRhW0NvdW50ZXJdLlJlY2VpdmUudG90YWw7CiAgICAgICAJICAgICAgICB0b3RhbDJbeGludF0gKz0gRGF0YVtDb3VudGVyXS5SZWNlaXZlLnRvdGFsOwogICAgICAgICAgIAkgICAgaWNtcDJbeGludF0gKz0gRGF0YVtDb3VudGVyXS5SZWNlaXZlLmljbXA7CiAgICAgICAgICAgICAgIAl1ZHAyW3hpbnRdICs9IERhdGFbQ291bnRlcl0uUmVjZWl2ZS51ZHA7CiAgICAgICAgICAgICAgICB0Y3AyW3hpbnRdICs9IERhdGFbQ291bnRlcl0uUmVjZWl2ZS50Y3A7CgkJCQlmdHAyW3hpbnRdICs9IERhdGFbQ291bnRlcl0uUmVjZWl2ZS5mdHA7CiAgICAgICAJICAgICAgICBodHRwMlt4aW50XSArPSBEYXRhW0NvdW50ZXJdLlJlY2VpdmUuaHR0cDsKCQkJCXAycDJbeGludF0gKz0gRGF0YVtDb3VudGVyXS5SZWNlaXZlLnAycDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKCQlDdXJyZW50QmxvY2sgPSBDdXJyZW50QmxvY2stPk5leHQ7CgkJCQoJCWlmIChDdXJyZW50QmxvY2spCgkJCXsKICAgICAgICAgCURhdGEgPSBDdXJyZW50QmxvY2stPkRhdGE7CgkJCURhdGFQb2ludHMgPSBDdXJyZW50QmxvY2stPk51bUVudHJpZXM7CgkJCX0KCQllbHNlCgkJCURhdGFQb2ludHMgPSAwOwkJCiAgICAgICAgfQoKCS8vIENvbnZlcnQgU2VudFBlYWsgYW5kIFJlY2VpdmVkUGVhayBmcm9tIGJ5dGVzIHRvIGJ5dGVzL3NlY29uZAoJU2VudFBlYWsgLz0gY29uZmlnLmludGVydmFsOyBSZWNlaXZlZFBlYWsgLz0gY29uZmlnLmludGVydmFsOwoKICAgIC8vIFByZWZvcm0gdGhlIEF2ZXJhZ2UKICAgIGZvcihDb3VudGVyPVhPRkZTRVQrMTsgQ291bnRlciA8IFhXSURUSDsgQ291bnRlcisrKQogICAgICAgICAgICB7CiAgICAgICAgICAgIGlmIChDb3VudFtDb3VudGVyXSA+IDApCiAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgIAlTdW1tYXJ5RGF0YS0+VG90YWwgKz0gdG90YWxbQ291bnRlcl0gKyB0b3RhbDJbQ291bnRlcl07CgkJCQlTdW1tYXJ5RGF0YS0+VG90YWxTZW50ICs9IHRvdGFsW0NvdW50ZXJdOwogCQkJCVN1bW1hcnlEYXRhLT5Ub3RhbFJlY2VpdmVkICs9IHRvdGFsMltDb3VudGVyXTsKCQkJCVN1bW1hcnlEYXRhLT5UQ1AgKz0gdGNwW0NvdW50ZXJdICsgdGNwMltDb3VudGVyXTsKCQkJCVN1bW1hcnlEYXRhLT5GVFAgKz0gZnRwW0NvdW50ZXJdICsgZnRwMltDb3VudGVyXTsKCQkJCVN1bW1hcnlEYXRhLT5IVFRQICs9IGh0dHBbQ291bnRlcl0gKyBodHRwMltDb3VudGVyXTsKCQkJCVN1bW1hcnlEYXRhLT5QMlAgKz0gcDJwW0NvdW50ZXJdICsgcDJwMltDb3VudGVyXTsKCQkJCVN1bW1hcnlEYXRhLT5VRFAgKz0gdWRwW0NvdW50ZXJdICsgdWRwMltDb3VudGVyXTsKCQkJCVN1bW1hcnlEYXRhLT5JQ01QICs9IGljbXBbQ291bnRlcl0gKyBpY21wMltDb3VudGVyXTsKCiAgICAgICAgICAgICAgICAvLyBQcmVmb3JtIHRoZSBhdmVyYWdlCiAgICAgICAgICAgICAgICB0b3RhbFtDb3VudGVyXSAvPSAoQ291bnRbQ291bnRlcl0qY29uZmlnLmludGVydmFsKTsKICAgICAgICAgICAgICAgIHRjcFtDb3VudGVyXSAvPSAoQ291bnRbQ291bnRlcl0qY29uZmlnLmludGVydmFsKTsKICAgICAgICAgICAgICAgIGZ0cFtDb3VudGVyXSAvPSAoQ291bnRbQ291bnRlcl0qY29uZmlnLmludGVydmFsKTsKICAgICAgICAgICAgICAgIGh0dHBbQ291bnRlcl0gLz0gKENvdW50W0NvdW50ZXJdKmNvbmZpZy5pbnRlcnZhbCk7CgkJCQlwMnBbQ291bnRlcl0gLz0gKENvdW50W0NvdW50ZXJdKmNvbmZpZy5pbnRlcnZhbCk7CiAgICAgICAgICAgICAgICB1ZHBbQ291bnRlcl0gLz0gKENvdW50W0NvdW50ZXJdKmNvbmZpZy5pbnRlcnZhbCk7CiAgICAgICAgICAgICAgICBpY21wW0NvdW50ZXJdIC89IChDb3VudFtDb3VudGVyXSpjb25maWcuaW50ZXJ2YWwpOwoJCQkJCQkJCQogICAgICAgICAgICAgICAgdG90YWwyW0NvdW50ZXJdIC89IChDb3VudFtDb3VudGVyXSpjb25maWcuaW50ZXJ2YWwpOwogICAgICAgICAgICAgICAgdGNwMltDb3VudGVyXSAvPSAoQ291bnRbQ291bnRlcl0qY29uZmlnLmludGVydmFsKTsKCQkJCWZ0cDJbQ291bnRlcl0gLz0gKENvdW50W0NvdW50ZXJdKmNvbmZpZy5pbnRlcnZhbCk7CiAgICAgICAgICAgICAgICBodHRwMltDb3VudGVyXSAvPSAoQ291bnRbQ291bnRlcl0qY29uZmlnLmludGVydmFsKTsKCQkJCXAycDJbQ291bnRlcl0gLz0gKENvdW50W0NvdW50ZXJdKmNvbmZpZy5pbnRlcnZhbCk7CiAgICAgICAgICAgICAgICB1ZHAyW0NvdW50ZXJdIC89IChDb3VudFtDb3VudGVyXSpjb25maWcuaW50ZXJ2YWwpOwogICAgICAgICAgICAgICAgaWNtcDJbQ291bnRlcl0gLz0gKENvdW50W0NvdW50ZXJdKmNvbmZpZy5pbnRlcnZhbCk7CgoKICAgICAgICAgICAgICAgIGlmICh0b3RhbFtDb3VudGVyXSA+IFlNYXgpCiAgICAgICAgICAgICAgICAgICAgWU1heCA9IHRvdGFsW0NvdW50ZXJdOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAodG90YWwyW0NvdW50ZXJdID4gWU1heCkKICAgICAgICAgICAgICAgICAgICBZTWF4ID0gdG90YWwyW0NvdW50ZXJdOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgWU1heCArPSBZTWF4KjAuMDU7ICAgIC8vIEFkZCBhbiBleHRyYSA1JQoJCiAgICBpZiAoKFN1bW1hcnlEYXRhLT5JUCAhPSAwICYmIFN1bW1hcnlEYXRhLT5Ub3RhbCA8IGNvbmZpZy5ncmFwaF9jdXRvZmYpKQoJCXsKCQlTdW1tYXJ5RGF0YS0+R3JhcGggPSBGQUxTRTsKICAgICAgICByZXR1cm4oMCk7CgkJfQoJZWxzZQogICAgICAgIFN1bW1hcnlEYXRhLT5HcmFwaCA9IFRSVUU7CgogICAgLy8gUGxvdCB0aGUgcG9pbnRzCiAgICBmb3IoQ291bnRlcj1YT0ZGU0VUKzE7IENvdW50ZXIgPCBYV0lEVEg7IENvdW50ZXIrKykgICAgCiAgICAgICAgICAgIHsKICAgICAgICAgICAgaWYgKENvdW50W0NvdW50ZXJdID4gMCkKICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGJ5dGVzL3NlYyB0byB5IGNvb3JkcwogICAgICAgICAgICAgICAgdG90YWxbQ291bnRlcl0gPSAodG90YWxbQ291bnRlcl0qKFlIRUlHSFQtWU9GRlNFVCkpL1lNYXg7CiAgICAgICAgICAgICAgICB0Y3BbQ291bnRlcl0gPSAodGNwW0NvdW50ZXJdKihZSEVJR0hULVlPRkZTRVQpKS9ZTWF4OwogICAgICAgICAgICAgICAgZnRwW0NvdW50ZXJdID0gKGZ0cFtDb3VudGVyXSooWUhFSUdIVC1ZT0ZGU0VUKSkvWU1heDsKICAgICAgICAgICAgICAgIGh0dHBbQ291bnRlcl0gPSAoaHR0cFtDb3VudGVyXSooWUhFSUdIVC1ZT0ZGU0VUKSkvWU1heDsKICAgICAgICAgICAgICAgIHAycFtDb3VudGVyXSA9IChwMnBbQ291bnRlcl0qKFlIRUlHSFQtWU9GRlNFVCkpL1lNYXg7CiAgICAgICAgICAgICAgICB1ZHBbQ291bnRlcl0gPSAodWRwW0NvdW50ZXJdKihZSEVJR0hULVlPRkZTRVQpKS9ZTWF4OwogICAgICAgICAgICAgICAgaWNtcFtDb3VudGVyXSA9IChpY21wW0NvdW50ZXJdKihZSEVJR0hULVlPRkZTRVQpKS9ZTWF4OwoKICAgICAgICAgICAgICAgIHRvdGFsMltDb3VudGVyXSA9ICh0b3RhbDJbQ291bnRlcl0qKFlIRUlHSFQtWU9GRlNFVCkpL1lNYXg7CiAgICAgICAgICAgICAgICB0Y3AyW0NvdW50ZXJdID0gKHRjcDJbQ291bnRlcl0qKFlIRUlHSFQtWU9GRlNFVCkpL1lNYXg7CiAgICAgICAgICAgICAgICBmdHAyW0NvdW50ZXJdID0gKGZ0cDJbQ291bnRlcl0qKFlIRUlHSFQtWU9GRlNFVCkpL1lNYXg7CiAgICAgICAgICAgICAgICBodHRwMltDb3VudGVyXSA9IChodHRwMltDb3VudGVyXSooWUhFSUdIVC1ZT0ZGU0VUKSkvWU1heDsKCQkJCXAycDJbQ291bnRlcl0gPSAocDJwMltDb3VudGVyXSooWUhFSUdIVC1ZT0ZGU0VUKSkvWU1heDsKICAgICAgICAgICAgICAgIHVkcDJbQ291bnRlcl0gPSAodWRwMltDb3VudGVyXSooWUhFSUdIVC1ZT0ZGU0VUKSkvWU1heDsKICAgICAgICAgICAgICAgIGljbXAyW0NvdW50ZXJdID0gKGljbXAyW0NvdW50ZXJdKihZSEVJR0hULVlPRkZTRVQpKS9ZTWF4OwoKICAgICAgICAgICAgICAgIC8vIFN0YWNrICdlbSB1cCEKICAgICAgICAgICAgICAgIC8vIFRvdGFsIGlzIHN0YWNrZWQgZnJvbSB0aGUgYm90dG9tCiAgICAgICAgICAgICAgICAvLyBJY21wIGlzIG9uIHRoZSBib3R0b20gdG9vCiAgICAgICAgICAgICAgICAvLyBVZHAgaXMgc3RhY2tlZCBvbiB0b3Agb2YgaWNtcAogICAgICAgICAgICAgICAgdWRwW0NvdW50ZXJdICs9IGljbXBbQ291bnRlcl07CgkJCQl1ZHAyW0NvdW50ZXJdICs9IGljbXAyW0NvdW50ZXJdOwogICAgICAgICAgICAgICAgLy8gVENQIGFuZCBwMnAgYXJlIHN0YWNrZWQgb24gdG9wIG9mIFVkcAogICAgICAgICAgICAgICAgdGNwW0NvdW50ZXJdICs9IHVkcFtDb3VudGVyXTsKICAgICAgICAgICAgICAgIHRjcDJbQ291bnRlcl0gKz0gdWRwMltDb3VudGVyXTsKICAgICAgICAgICAgICAgIHAycFtDb3VudGVyXSArPSB1ZHBbQ291bnRlcl07CiAgICAgICAgICAgICAgICBwMnAyW0NvdW50ZXJdICs9IHVkcDJbQ291bnRlcl07CgkJCQkvLyBIdHRwIGlzIHN0YWNrZWQgb24gdG9wIG9mIHAycAogICAgICAgICAgICAgICAgaHR0cFtDb3VudGVyXSArPSBwMnBbQ291bnRlcl07CiAgICAgICAgICAgICAgICBodHRwMltDb3VudGVyXSArPSBwMnAyW0NvdW50ZXJdOwoJCQkJLy8gRnRwIGlzIHN0YWNrZWQgb24gdG9wIG9mIGh0dHAKICAgICAgICAgICAgICAgIGZ0cFtDb3VudGVyXSArPSBodHRwW0NvdW50ZXJdOwogICAgICAgICAgICAgICAgZnRwMltDb3VudGVyXSArPSBodHRwMltDb3VudGVyXTsKCiAgICAgICAgICAgICAgICAvLyBQbG90IHRoZW0hCgkJCQkvLyBTZW50CiAgICAgICAgICAgICAgICBnZEltYWdlTGluZShpbSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBpY21wW0NvdW50ZXJdLCBDb3VudGVyLCBZSEVJR0hULVlPRkZTRVQtMSwgcmVkKTsKICAgICAgICAgICAgICAgIGdkSW1hZ2VMaW5lKGltLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIHVkcFtDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBpY21wW0NvdW50ZXJdIC0gMSwgYnJvd24pOwogICAgICAgICAgICAgICAgZ2RJbWFnZUxpbmUoaW0sIENvdW50ZXIsIChZSEVJR0hULVlPRkZTRVQpIC0gdGNwW0NvdW50ZXJdLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIHVkcFtDb3VudGVyXSAtIDEsIGdyZWVuKTsKICAgICAgICAgICAgICAgIGdkSW1hZ2VMaW5lKGltLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIHAycFtDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSB1ZHBbQ291bnRlcl0gLSAxLCBwdXJwbGUpOwogICAgICAgICAgICAgICAgZ2RJbWFnZUxpbmUoaW0sIENvdW50ZXIsIChZSEVJR0hULVlPRkZTRVQpIC0gaHR0cFtDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBwMnBbQ291bnRlcl0gLSAxLCBibHVlKTsKICAgICAgICAgICAgICAgIGdkSW1hZ2VMaW5lKGltLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIGZ0cFtDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBodHRwW0NvdW50ZXJdIC0gMSwgbGJsdWUpOwoJCQkJCQkJCQoJCQkJLy8gUmVjZWl2ZQogICAgICAgICAgICAgICAgZ2RJbWFnZUxpbmUoaW0yLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIGljbXAyW0NvdW50ZXJdLCBDb3VudGVyLCBZSEVJR0hULVlPRkZTRVQtMSwgcmVkMik7CiAgICAgICAgICAgICAgICBnZEltYWdlTGluZShpbTIsIENvdW50ZXIsIChZSEVJR0hULVlPRkZTRVQpIC0gdWRwMltDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBpY21wMltDb3VudGVyXSAtIDEsIGJyb3duMik7CiAgICAgICAgICAgICAgICBnZEltYWdlTGluZShpbTIsIENvdW50ZXIsIChZSEVJR0hULVlPRkZTRVQpIC0gdGNwMltDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSB1ZHAyW0NvdW50ZXJdIC0gMSwgZ3JlZW4yKTsKICAgICAgICAgICAgICAgIGdkSW1hZ2VMaW5lKGltMiwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBwMnAyW0NvdW50ZXJdLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIHVkcDJbQ291bnRlcl0gLSAxLCBwdXJwbGUyKTsKICAgICAgICAgICAgICAgIGdkSW1hZ2VMaW5lKGltMiwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBodHRwMltDb3VudGVyXSwgQ291bnRlciwgKFlIRUlHSFQtWU9GRlNFVCkgLSBwMnAyW0NvdW50ZXJdIC0gMSwgYmx1ZTIpOwogICAgICAgICAgICAgICAgZ2RJbWFnZUxpbmUoaW0yLCBDb3VudGVyLCAoWUhFSUdIVC1ZT0ZGU0VUKSAtIGZ0cDJbQ291bnRlcl0sIENvdW50ZXIsIChZSEVJR0hULVlPRkZTRVQpIC0gaHR0cDJbQ291bnRlcl0gLSAxLCBsYmx1ZTIpOwoKCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KCglpZiAoU2VudFBlYWsgPCAxMDI0LzgpCgkJc25wcmludGYoQnVmZmVyMiwgNTAsICJQZWFrIFNlbmQgUmF0ZTogJS4xZiBCaXRzL3NlYyIsIChkb3VibGUpU2VudFBlYWsqOCk7CgllbHNlIGlmIChTZW50UGVhayA8ICgxMDI0KjEwMjQpLzgpCgkJc25wcmludGYoQnVmZmVyMiwgNTAsICJQZWFrIFNlbmQgUmF0ZTogJS4xZiBLQml0cy9zZWMiLCAoKGRvdWJsZSlTZW50UGVhayo4LjApLzEwMjQuMCk7CgllbHNlIHNucHJpbnRmKEJ1ZmZlcjIsIDUwLCAiUGVhayBTZW5kIFJhdGU6ICUuMWYgTUJpdHMvc2VjIiwgKChkb3VibGUpU2VudFBlYWsqOC4wKS8oMTAyNC4wKjEwMjQuMCkpOwoJCQkJCQkJCQoJaWYgKFN1bW1hcnlEYXRhLT5Ub3RhbFNlbnQgPCAxMDI0KQoJCXNucHJpbnRmKEJ1ZmZlciwgMzAsICJTZW50ICUuMWYgQnl0ZXMiLCAoZG91YmxlKVN1bW1hcnlEYXRhLT5Ub3RhbFNlbnQpOwkJCQkJCgllbHNlIGlmIChTdW1tYXJ5RGF0YS0+VG90YWxTZW50IDwgMTAyNCoxMDI0KQoJCXNucHJpbnRmKEJ1ZmZlciwgMzAsICJTZW50ICUuMWYgS0J5dGVzIiwgKGRvdWJsZSlTdW1tYXJ5RGF0YS0+VG90YWxTZW50LzEwMjQuMCk7CgllbHNlIHNucHJpbnRmKEJ1ZmZlciwgMzAsICJTZW50ICUuMWYgTUJ5dGVzIiwgKGRvdWJsZSlTdW1tYXJ5RGF0YS0+VG90YWxTZW50LygxMDI0LjAqMTAyNC4wKSk7CgoJZ2RJbWFnZVN0cmluZyhpbSwgZ2RGb250U21hbGwsIFhPRkZTRVQrNSwgIFlIRUlHSFQtMjAsIEJ1ZmZlciwgYmxhY2spOwoJZ2RJbWFnZVN0cmluZyhpbSwgZ2RGb250U21hbGwsIFhXSURUSC8yK1hPRkZTRVQvMiwgIFlIRUlHSFQtMjAsIEJ1ZmZlcjIsIGJsYWNrKTsJCQkJCgoJaWYgKFJlY2VpdmVkUGVhayA8IDEwMjQvOCkKICAgICAgIAlzbnByaW50ZihCdWZmZXIyLCA1MCwgIlBlYWsgUmVjZWl2ZSBSYXRlOiAlLjFmIEJpdHMvc2VjIiwgKGRvdWJsZSlSZWNlaXZlZFBlYWsqOCk7CiAgICBlbHNlIGlmIChSZWNlaXZlZFBlYWsgPCAoMTAyNCoxMDI0KS84KQogICAgCXNucHJpbnRmKEJ1ZmZlcjIsIDUwLCAiUGVhayBSZWNlaXZlIFJhdGU6ICUuMWYgS0JpdHMvc2VjIiwgKChkb3VibGUpUmVjZWl2ZWRQZWFrKjguMCkvMTAyNC4wKTsgICAgICAgICAgICAgICAKCWVsc2Ugc25wcmludGYoQnVmZmVyMiwgNTAsICJQZWFrIFJlY2VpdmUgUmF0ZTogJS4xZiBNQml0cy9zZWMiLCAoKGRvdWJsZSlSZWNlaXZlZFBlYWsqOC4wKS8oMTAyNC4wKjEwMjQuMCkpOwoKICAgIGlmIChTdW1tYXJ5RGF0YS0+VG90YWxSZWNlaXZlZCA8IDEwMjQpCiAgICAgICAgc25wcmludGYoQnVmZmVyLCAzMCwgIlJlY2VpdmVkICUuMWYgQnl0ZXMiLCAoZG91YmxlKVN1bW1hcnlEYXRhLT5Ub3RhbFJlY2VpdmVkKTsKICAgIGVsc2UgaWYgKFN1bW1hcnlEYXRhLT5Ub3RhbFJlY2VpdmVkIDwgMTAyNCoxMDI0KQogICAgICAgIHNucHJpbnRmKEJ1ZmZlciwgMzAsICJSZWNlaXZlZCAlLjFmIEtCeXRlcyIsIChkb3VibGUpU3VtbWFyeURhdGEtPlRvdGFsUmVjZWl2ZWQvMTAyNC4wKTsKICAgIGVsc2Ugc25wcmludGYoQnVmZmVyLCAzMCwgIlJlY2VpdmVkICUuMWYgTUJ5dGVzIiwgKGRvdWJsZSlTdW1tYXJ5RGF0YS0+VG90YWxSZWNlaXZlZC8oMTAyNC4wKjEwMjQuMCkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgZ2RJbWFnZVN0cmluZyhpbTIsIGdkRm9udFNtYWxsLCBYT0ZGU0VUKzUsICBZSEVJR0hULTIwLCBCdWZmZXIsIGJsYWNrMik7ICAgICAgICAgICAgICAgIAogICAgZ2RJbWFnZVN0cmluZyhpbTIsIGdkRm9udFNtYWxsLCBYV0lEVEgvMitYT0ZGU0VULzIsICBZSEVJR0hULTIwLCBCdWZmZXIyLCBibGFjazIpOwoKICAgIHJldHVybihZTWF4KTsKICAgIH0KCnZvaWQgUHJlcGFyZVlBeGlzKGdkSW1hZ2VQdHIgaW0sIHVuc2lnbmVkIGxvbmcgbG9uZyBpbnQgWU1heCkKICAgIHsKICAgIGNoYXIgYnVmZmVyWzIwXTsKCgljaGFyIFlMZWdlbmQ7Cglsb25nIGxvbmcgaW50IERpdmlzb3I7CgogICAgaW50IGJsYWNrOwogICAgZmxvYXQgWVRpYyA9IDA7CiAgICBkb3VibGUgeTsKICAgIGxvbmcgaW50IFlTdGVwOwogICAgCiAgICBibGFjayA9IGdkSW1hZ2VDb2xvckFsbG9jYXRlKGltLCAwLCAwLCAwKTsKICAgIGdkSW1hZ2VMaW5lKGltLCBYT0ZGU0VULCAwLCBYT0ZGU0VULCBZSEVJR0hULCBibGFjayk7CgogICAgWUxlZ2VuZCA9ICcgJzsKICAgIERpdmlzb3IgPSAxOwogICAgaWYgKFlNYXgqOCA+IDEwMjQqMikKICAgICAgICB7CiAgICAgICAgRGl2aXNvciA9IDEwMjQ7ICAgIC8vIERpc3BsYXkgaW4gSwogICAgICAgIFlMZWdlbmQgPSAnayc7CiAgICAgICAgfQogICAgaWYgKFlNYXgqOCA+IDEwMjQqMTAyNCoyKQogICAgICAgIHsKICAgICAgICBEaXZpc29yID0gMTAyNCoxMDI0OyAvLyBEaXNwbGF5IGluIE0KICAgICAgICBZTGVnZW5kID0gJ20nOwogICAgICAgIH0KICAgIGlmIChZTWF4KjggPiAobG9uZyBsb25nKTEwMjQqMTAyNCoxMDI0KjIpCiAgICAgICAgewogICAgICAgIERpdmlzb3IgPSAxMDI0KjEwMjQqMTAyNDsgLy8gRGlzcGxheSBpbiBHCiAgICAgICAgWUxlZ2VuZCA9ICdnJzsKICAgICAgICB9CgogICAgWVN0ZXAgPSBZTWF4LzEwOwogICAgaWYgKFlTdGVwIDwgMSkKICAgICAgICBZU3RlcD0xOwogICAgWVRpYz1ZU3RlcDsKCiAgICB3aGlsZSAoWVRpYyA8IChZTWF4IC0gWU1heC8xMCkpCiAgICAgICAgewogICAgICAgIHkgPSAoWUhFSUdIVC1ZT0ZGU0VUKS0oKFlUaWMqKFlIRUlHSFQtWU9GRlNFVCkpL1lNYXgpOyAgICAgICAgCgogICAgICAgIGdkSW1hZ2VMaW5lKGltLCBYT0ZGU0VULCB5LCBYV0lEVEgsIHksIGJsYWNrKTsgICAgICAgIAogICAgICAgIHNucHJpbnRmKGJ1ZmZlciwgMjAsICIlNC4xZiAlY2JpdHMvcyIsIChmbG9hdCkoOC4wKllUaWMpL0Rpdmlzb3IsIFlMZWdlbmQpOwogICAgICAgIGdkSW1hZ2VTdHJpbmcoaW0sIGdkRm9udFNtYWxsLCAzLCB5LTcsIGJ1ZmZlciwgYmxhY2spOyAgICAgICAgCgogICAgICAgIFlUaWMgKz0gWVN0ZXA7CiAgICAgICAgfQogICAgfSAKCnZvaWQgUHJlcGFyZVhBeGlzKGdkSW1hZ2VQdHIgaW0sIHRpbWVfdCB0aW1lc3RhbXApCiAgICB7CiAgICBjaGFyIGJ1ZmZlclsxMDBdOwogICAgaW50IGJsYWNrLCByZWQ7CiAgICB0aW1lX3Qgc2FtcGxlX2JlZ2luLCBzYW1wbGVfZW5kOyAgICAKICAgIHN0cnVjdCB0bSAqdGltZXN0cnVjdDsKICAgIGxvbmcgaW50IE1hcmtUaW1lOwoJbG9uZyBpbnQgTWFya1RpbWVTdGVwOwogICAgZG91YmxlIHg7CiAgICAKICAgIHNhbXBsZV9iZWdpbj10aW1lc3RhbXAtY29uZmlnLnJhbmdlOwogICAgc2FtcGxlX2VuZD1zYW1wbGVfYmVnaW4rY29uZmlnLmludGVydmFsOwoKICAgIGJsYWNrID0gZ2RJbWFnZUNvbG9yQWxsb2NhdGUoaW0sIDAsIDAsIDApOwogICAgcmVkICAgPSBnZEltYWdlQ29sb3JBbGxvY2F0ZShpbSwgMjU1LCAwLCAwKTsKCiAgICBnZEltYWdlTGluZShpbSwgMCwgWUhFSUdIVC1ZT0ZGU0VULCBYV0lEVEgsIFlIRUlHSFQtWU9GRlNFVCwgYmxhY2spOwoKICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCiAgICAvLyAqKioqICBXcml0ZSB0aGUgcmVkIGRheS9tb250aCBzZXBlcmF0b3IgYmFycwogICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKCglpZiAoKDI0KjYwKjYwKihYV0lEVEgtWE9GRlNFVCkpL2NvbmZpZy5yYW5nZSA+IChYV0lEVEgtWE9GRlNFVCkvMTApCgkJewoJCS8vIERheSBiYXJzCgkgICAgdGltZXN0cnVjdCA9IGxvY2FsdGltZSgodGltZV90ICopJnNhbXBsZV9iZWdpbik7CiAgICAJdGltZXN0cnVjdC0+dG1fc2VjID0gMDsKCSAgICB0aW1lc3RydWN0LT50bV9taW4gPSAwOwogICAgCXRpbWVzdHJ1Y3QtPnRtX2hvdXIgPSAwOwoJICAgIE1hcmtUaW1lID0gbWt0aW1lKHRpbWVzdHJ1Y3QpOwogICAgICAgICAgICAKICAgIAl4ID0gKE1hcmtUaW1lLXNhbXBsZV9iZWdpbikqKCAoKGRvdWJsZSkoWFdJRFRILVhPRkZTRVQpKSAvIGNvbmZpZy5yYW5nZSkgKyBYT0ZGU0VUOwoJICAgIHdoaWxlICh4IDwgWE9GRlNFVCkKICAgIAkgICAgewogICAgICAgIAlNYXJrVGltZSArPSAoMjQqNjAqNjApOwoJICAgICAgICB4ID0gKE1hcmtUaW1lLXNhbXBsZV9iZWdpbikqKChYV0lEVEgtWE9GRlNFVCkvY29uZmlnLnJhbmdlKSArIFhPRkZTRVQ7CiAgICAJICAgIH0KCgkgICAgd2hpbGUgKHggPCAoWFdJRFRILTEwKSkKICAgIAkgICAgewogICAgICAgIAkvLyBEYXkgTGluZXMKCSAgICAgICAgZ2RJbWFnZUxpbmUoaW0sIHgsIDAsIHgsIFlIRUlHSFQtWU9GRlNFVCwgcmVkKTsKICAgIAkgICAgZ2RJbWFnZUxpbmUoaW0sIHgrMSwgMCwgeCsxLCBZSEVJR0hULVlPRkZTRVQsIHJlZCk7CgkKICAgIAkgICAgdGltZXN0cnVjdCA9IGxvY2FsdGltZSgodGltZV90ICopJk1hcmtUaW1lKTsKCSAgICAgICAgc3RyZnRpbWUoYnVmZmVyLCAxMDAsICIlYSwgJWIgJWQiLCB0aW1lc3RydWN0KTsKICAgIAkgICAgZ2RJbWFnZVN0cmluZyhpbSwgZ2RGb250U21hbGwsIHgtMzAsICBZSEVJR0hULVlPRkZTRVQrMTAsIGJ1ZmZlciwgYmxhY2spOyAgICAgICAgCgoJICAgICAgICAvLyBDYWxjdWxhdGUgTmV4dCB4CiAgICAJICAgIE1hcmtUaW1lICs9ICgyNCo2MCo2MCk7CiAgICAgICAgCXggPSAoTWFya1RpbWUtc2FtcGxlX2JlZ2luKSooKFhXSURUSC1YT0ZGU0VUKS9jb25maWcucmFuZ2UpICsgWE9GRlNFVDsKCSAgICAgICAgfQoJCX0KCWVsc2UKCQl7CiAgICAJLy8gTW9udGggQmFycwogICAgICAgIHRpbWVzdHJ1Y3QgPSBsb2NhbHRpbWUoKHRpbWVfdCAqKSZzYW1wbGVfYmVnaW4pOwogICAgICAgIHRpbWVzdHJ1Y3QtPnRtX3NlYyA9IDA7CiAgICAgICAgdGltZXN0cnVjdC0+dG1fbWluID0gMDsKICAgICAgICB0aW1lc3RydWN0LT50bV9ob3VyID0gMDsKCQl0aW1lc3RydWN0LT50bV9tZGF5ID0gMTsKCQl0aW1lc3RydWN0LT50bV9tb24tLTsgLy8gU3RhcnQgdGhlIG1vbnRoIGJlZm9yZSB0aGUgc2FtcGxlCiAgICAgICAgTWFya1RpbWUgPSBta3RpbWUodGltZXN0cnVjdCk7CgogICAgCXggPSAoTWFya1RpbWUtc2FtcGxlX2JlZ2luKSooICgoZG91YmxlKShYV0lEVEgtWE9GRlNFVCkpIC8gY29uZmlnLnJhbmdlKSArIFhPRkZTRVQ7CgkgICAgd2hpbGUgKHggPCBYT0ZGU0VUKQogICAgCSAgICB7CgkJCXRpbWVzdHJ1Y3QtPnRtX21vbisrOwogICAgICAgIAlNYXJrVGltZSA9IG1rdGltZSh0aW1lc3RydWN0KTsKCSAgICAgICAgeCA9IChNYXJrVGltZS1zYW1wbGVfYmVnaW4pKigoWFdJRFRILVhPRkZTRVQpL2NvbmZpZy5yYW5nZSkgKyBYT0ZGU0VUOwogICAgCSAgICB9CgoJICAgIHdoaWxlICh4IDwgKFhXSURUSC0xMCkpCiAgICAJICAgIHsKICAgICAgICAJLy8gTW9udGggTGluZXMKCSAgICAgICAgZ2RJbWFnZUxpbmUoaW0sIHgsIDAsIHgsIFlIRUlHSFQtWU9GRlNFVCwgcmVkKTsKICAgIAkgICAgZ2RJbWFnZUxpbmUoaW0sIHgrMSwgMCwgeCsxLCBZSEVJR0hULVlPRkZTRVQsIHJlZCk7CgkKICAgIAkgICAgdGltZXN0cnVjdCA9IGxvY2FsdGltZSgodGltZV90ICopJk1hcmtUaW1lKTsKCSAgICAgICAgc3RyZnRpbWUoYnVmZmVyLCAxMDAsICIlYiIsIHRpbWVzdHJ1Y3QpOwogICAgCSAgICBnZEltYWdlU3RyaW5nKGltLCBnZEZvbnRTbWFsbCwgeC02LCAgWUhFSUdIVC1ZT0ZGU0VUKzEwLCBidWZmZXIsIGJsYWNrKTsgICAgICAgIAoKCSAgICAgICAgLy8gQ2FsY3VsYXRlIE5leHQgeAogICAgICAgICAgICB0aW1lc3RydWN0LT50bV9tb24rKzsKICAgICAgICAgICAgTWFya1RpbWUgPSBta3RpbWUodGltZXN0cnVjdCk7CiAgICAgICAgCXggPSAoTWFya1RpbWUtc2FtcGxlX2JlZ2luKSooKFhXSURUSC1YT0ZGU0VUKS9jb25maWcucmFuZ2UpICsgWE9GRlNFVDsKCSAgICAgICAgfQkJCQkKCQl9CgogICAgLy8gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioKICAgIC8vICoqKiogIFdyaXRlIHRoZSB0aWMgbWFya3MKICAgIC8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqCgogICAgdGltZXN0cnVjdCA9IGxvY2FsdGltZSgodGltZV90ICopJnNhbXBsZV9iZWdpbik7CiAgICB0aW1lc3RydWN0LT50bV9zZWMgPSAwOwogICAgdGltZXN0cnVjdC0+dG1fbWluID0gMDsKICAgIHRpbWVzdHJ1Y3QtPnRtX2hvdXIgPSAwOwogICAgTWFya1RpbWUgPSBta3RpbWUodGltZXN0cnVjdCk7CgoJaWYgKCg2KjYwKjYwKihYV0lEVEgtWE9GRlNFVCkpL2NvbmZpZy5yYW5nZSA+IDEwKSAvLyBwaXhlbHMgcGVyIDYgaG91cnMgaXMgbW9yZSB0aGFuIDIKCQlNYXJrVGltZVN0ZXAgPSA2KjYwKjYwOyAvLyBNYWpvciB0aWNrcyBhcmUgNiBob3VycwoJZWxzZSBpZiAoKDI0KjYwKjYwKihYV0lEVEgtWE9GRlNFVCkpL2NvbmZpZy5yYW5nZSA+IDEwKQoJCU1hcmtUaW1lU3RlcCA9IDI0KjYwKjYwOyAvLyBNYWpvciB0aWNrcyBhcmUgMjQgaG91cnM7CgllbHNlCgkJcmV0dXJuOyAvLyBEb25lCQkKCgl4ID0gKE1hcmtUaW1lLXNhbXBsZV9iZWdpbikqKChYV0lEVEgtWE9GRlNFVCkvY29uZmlnLnJhbmdlKSArIFhPRkZTRVQ7Cgl3aGlsZSAoeCA8IFhPRkZTRVQpCiAgIAkJewoJCU1hcmtUaW1lICs9IE1hcmtUaW1lU3RlcDsKCSAgICB4ID0gKE1hcmtUaW1lLXNhbXBsZV9iZWdpbikqKChYV0lEVEgtWE9GRlNFVCkvY29uZmlnLnJhbmdlKSArIFhPRkZTRVQ7CiAgICAJfQoKICAgIHdoaWxlICh4IDwgKFhXSURUSC0xMCkpCiAgICAJewoJICAgIGlmICh4ID4gWE9GRlNFVCkgewogICAgCQlnZEltYWdlTGluZShpbSwgeCwgWUhFSUdIVC1ZT0ZGU0VULTUsIHgsIFlIRUlHSFQtWU9GRlNFVCs1LCBibGFjayk7CgkgICAgICAgCWdkSW1hZ2VMaW5lKGltLCB4KzEsIFlIRUlHSFQtWU9GRlNFVC01LCB4KzEsIFlIRUlHSFQtWU9GRlNFVCs1LCBibGFjayk7CiAgICAgICAgCX0KCQlNYXJrVGltZSArPSBNYXJrVGltZVN0ZXA7CiAgIAkJeCA9IChNYXJrVGltZS1zYW1wbGVfYmVnaW4pKigoWFdJRFRILVhPRkZTRVQpL2NvbmZpZy5yYW5nZSkgKyBYT0ZGU0VUOwogICAgICAgIH0KCiAgICB0aW1lc3RydWN0ID0gbG9jYWx0aW1lKCh0aW1lX3QgKikmc2FtcGxlX2JlZ2luKTsKICAgIHRpbWVzdHJ1Y3QtPnRtX3NlYyA9IDA7CiAgICB0aW1lc3RydWN0LT50bV9taW4gPSAwOwogICAgdGltZXN0cnVjdC0+dG1faG91ciA9IDA7CiAgICBNYXJrVGltZSA9IG1rdGltZSh0aW1lc3RydWN0KTsKCglpZiAoKDYwKjYwKihYV0lEVEgtWE9GRlNFVCkpL2NvbmZpZy5yYW5nZSA+IDIpIC8vIHBpeGVscyBwZXIgaG91ciBpcyBtb3JlIHRoYW4gMgoJCU1hcmtUaW1lU3RlcCA9IDYwKjYwOyAgLy8gTWlub3IgdGlja3MgYXJlIDEgaG91cgoJZWxzZSBpZiAoKDYqNjAqNjAqKFhXSURUSC1YT0ZGU0VUKSkvY29uZmlnLnJhbmdlID4gMikKCQlNYXJrVGltZVN0ZXAgPSA2KjYwKjYwOyAvLyBNaW5vciB0aWNrcyBhcmUgNiBob3VycwoJZWxzZSBpZiAoKDI0KjYwKjYwKihYV0lEVEgtWE9GRlNFVCkpL2NvbmZpZy5yYW5nZSA+IDIpCgkJTWFya1RpbWVTdGVwID0gMjQqNjAqNjA7CgllbHNlCgkJcmV0dXJuOyAvLyBEb25lCgoJLy8gRHJhdyBNaW5vciBUaWMgTWFya3MKCXggPSAoTWFya1RpbWUtc2FtcGxlX2JlZ2luKSooKFhXSURUSC1YT0ZGU0VUKS9jb25maWcucmFuZ2UpICsgWE9GRlNFVDsKCgl3aGlsZSAoeCA8IFhPRkZTRVQpCiAgIAkJewoJCU1hcmtUaW1lICs9IE1hcmtUaW1lU3RlcDsKCSAgICB4ID0gKE1hcmtUaW1lLXNhbXBsZV9iZWdpbikqKChYV0lEVEgtWE9GRlNFVCkvY29uZmlnLnJhbmdlKSArIFhPRkZTRVQ7CiAgICAJfQoKICAgIHdoaWxlICh4IDwgKFhXSURUSC0xMCkpCiAgICAgICAgewoJICAgIGlmICh4ID4gWE9GRlNFVCkgewogICAgCQlnZEltYWdlTGluZShpbSwgeCwgWUhFSUdIVC1ZT0ZGU0VULCB4LCBZSEVJR0hULVlPRkZTRVQrNSwgYmxhY2spOwogICAgICAgIAlnZEltYWdlTGluZShpbSwgeCsxLCBZSEVJR0hULVlPRkZTRVQsIHgrMSwgWUhFSUdIVC1ZT0ZGU0VUKzUsIGJsYWNrKTsKICAgICAgICAgICAgfQoJICAgIE1hcmtUaW1lKz1NYXJrVGltZVN0ZXA7CiAgICAJeCA9IChNYXJrVGltZS1zYW1wbGVfYmVnaW4pKigoWFdJRFRILVhPRkZTRVQpL2NvbmZpZy5yYW5nZSkgKyBYT0ZGU0VUOwogICAgICAgIH0KICAgIH0KCgo",
					"AQAAAAAAAAABAAAAAAAAAAAAAACPggAAAAAAAAAAAAAAAPC/"
				],
				[
					91,
					1,
					"insert",
					{
						"characters": "\t"
					},
					"AQAAAF4RAAAAAAAAXxEAAAAAAAAAAAAA",
					"AQAAAAAAAAABAAAAXhEAAAAAAABeEQAAAAAAAAAAAAAAAPC/"
				],
				[
					97,
					1,
					"right_delete",
					null,
					"AQAAAAASAAAAAAAAABIAAAAAAAABAAAACQ",
					"AQAAAAAAAAABAAAAABIAAAAAAAAAEgAAAAAAAAAAAAAAAFZA"
				],
				[
					101,
					1,
					"left_delete",
					null,
					"AQAAAEASAAAAAAAAQBIAAAAAAAABAAAACQ",
					"AQAAAAAAAAABAAAAQRIAAAAAAABBEgAAAAAAAAAAAAAAAFZA"
				]
			]
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"console":
	{
		"height": 0.0,
		"history":
		[
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/jim/development/bandwidthd2023",
		"/home/jim/development/bandwidthd2023/etc"
	],
	"file_history":
	[
		"/home/jim/development/bandwidthd2023/graph.c",
		"/home/jim/development/bandwidthd2023/bandwidthd.h",
		"/home/jim/development/bandwidthd2023/bandwidthd.spec",
		"/home/jim/development/bandwidthd2023/httpd.conf",
		"/home/jim/development/bandwidthd2023/phphtdocs/graph.php",
		"/home/jim/Books/ruby-deep-dive/ruby-deep-dive-v7/interactive-exercises.rb",
		"/home/jim/development/websites/jamesmcbrideus/index.html",
		"/home/jim/development/apps/apoxeia/log/capistrano.log",
		"/home/jim/development/apps/apoxeia/config/nginx-thecarringtonfirm.com.conf",
		"/home/jim/development/apps/apoxeia/yarn.list.txt",
		"/home/jim/development/apps/apoxeia/node_modules/node-forge/package.json",
		"/home/jim/development/apps/apoxeia/config/nginx-thecarringtonfirm.net.conf",
		"/home/jim/development/apps/apoxeia/config/nginx.conf.old",
		"/home/jim/development/apps/apoxeia/config/nginx.conf.older",
		"/home/jim/development/apps/apoxeia/config/nginx-thecarringtonfirm.com.conf-working",
		"/home/jim/development/apps/apoxeia/config/nginx-pedesis.us.conf",
		"/home/jim/development/apps/apoxeia/config/nginx-apoxeia.com.conf",
		"/home/jim/development/apps/apoxeia/config/schedule.rb",
		"/home/jim/development/apps/apoxeia/Gemfile",
		"/home/jim/development/apps/apoxeia/new_pc_setup.sh",
		"/media/jim/W10-USB-3-21-20/boot/grub/grub.cfg",
		"/home/jim/development/apps/apoxeia/Beth-Terri_Email_Questions",
		"/home/jim/development/apps/apoxeia/app/controllers/users_controller.rb",
		"/home/jim/pc_setup_script_run_log.log",
		"/home/jim/bin/new_pc_setup.sh",
		"/home/jim/development/apps/apoxeia/config/deploy.rb"
	],
	"find":
	{
		"height": 44.0
	},
	"find_in_files":
	{
		"height": 116.0,
		"where_history":
		[
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"HostIp2CharIp",
			"rdns",
			"Data",
			"HostIp2CharIp",
			"rdns",
			"HostName",
			"PrintTableline",
			"Ip and Name",
			"php ",
			"phphtdocs",
			"php",
			"end",
			"(\",\"),",
			"is not b"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"scrollbar_highlights": true,
		"show_context": true,
		"use_buffer2": true,
		"use_gitignore": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
				{
					"buffer": 0,
					"file": "graph.c",
					"selected": true,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 33794,
						"regions":
						{
						},
						"selection":
						[
							[
								4672,
								4672
							]
						],
						"settings":
						{
							"git_gutter_is_enabled": true,
							"syntax": "Packages/C++/C.sublime-syntax",
							"tab_size": 4,
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 3134.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"stack_multiselect": false,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 32.0
	},
	"input":
	{
		"height": 0.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.SublimeLinter":
	{
		"height": 0.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.unsaved_changes":
	{
		"height": 313.0
	},
	"pinned_build_system": "",
	"project": "bandwidth2023.sublime-project",
	"replace":
	{
		"height": 60.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"nginx",
				"config/nginx-thecarringtonfirm.com.conf"
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 166.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
